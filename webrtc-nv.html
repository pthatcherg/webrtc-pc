%<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>WebRTC NV</title>
  <script class="remove" src=
  "https://www.w3.org/Tools/respec/respec-w3c-common" type="text/javascript">
  // // keep this comment //
  </script>
  <script class="remove" src="webrtc.js" type="text/javascript">
  // // keep
    this comment //
  </script>
</head>
<!-- 

TODO: 
- RTCRtpCodecCapability
- stats

-->
<body>
  <section id="abstract">
    <p>This document defines a set of ECMAScript APIs in WebIDL to
    allow media to be sent to and received from another browser or
    device implementing the appropriate set of real-time
    protocols. It's an extension of WebRTC 1.0 intended to give more
    direct control over the objects in WebRTC 1.0.</p>
  </section>
  <section id="sotd">
    <p>This is an initial proposal.</p>
  </section>
  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>TODO</p>
  </section>
  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification MUST implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL-1]], as
    this specification uses that specification and terminology.</p>
  </section>
  <section>
    <h2>Terminology</h2>
    <p>The <code><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
    interface, representing a callback used for event handlers, and the
    <a href="http://dev.w3.org/html5/spec/webappapis.html#errorevent"><code><dfn>
    ErrorEvent</dfn></code></a> interface are defined in [[!HTML5]].</p>
    <p>The concepts <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a
    task</a></dfn>, <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a
    simple event</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#networking-task-source">networking
    task source</a></dfn> are defined in [[!HTML5]].</p>
    <p>The terms <dfn>event</dfn>, <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
    handlers</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
    handler event types</a></dfn> are defined in [[!HTML5]].</p>
    <p>The terms <dfn>MediaStream</dfn>, <dfn>MediaStreamTrack</dfn>, and
    <dfn>MediaStreamConstraints</dfn> are defined in [[!GETUSERMEDIA]].</p>

    <p>The term <dfn>Blob</dfn> is defined in [[!FILEAPI]].</p>
  </section>
  <section>
    <h2>RTP Media API</h2>
    <section>
      <h3>RTCRtpSender Interface Extensions</h3>
      <p>The <code><a>RtpSender</a></code> interface is extended as
      described below.</p>
      <div>
        <pre class="idl">[ Constructor () ]
partial interface RTCRtpSender {
    Promise&lt;void&gt; setTrack (optional MediaStreamTrack track);
    Promise&lt;void&gt; setTransport (optional RTCDtlsTransport transport);
    void                stop ();
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCRtpSender" data-dfn-for=
          "RTCRtpSender" class="constructors">
            <dt><code>RTCRtpSender</code></dt>
            <dd>
	      TODO
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCRtpSender" data-dfn-for=
          "RTCRtpSender" class="methods">
            <dt><code>setTrack</code></dt>
            <dd>
              <p>Exactly the same as replaceTrack, but with a name
              that makes sense for setting it the first time.  Media
              cannot be sent until the track, transport, and
              parameters are all set.</p>
            </dd>
            <dt><code>setTransport</code></dt>
            <dd>
              <p>TODO</p>
            </dd>
            <dt><code>stop</code></dt>
            <dd>
              <p>TODO</p>
            </dd>
          </dl>
        </section>
    </section>
    <section>
      <h3>RTCRtpReceiver Interface Extensions</h3>
      <p>The <code><a>RtpReceiver</a></code> interface is extended as
      described below.</p>
      <div>
        <pre class="idl">[ Constructor ()]
partial interface RTCRtpReceiver {
    Promise&lt;void&gt; setTransport (optional RTCDtlsTransport transport);
    Promise&lt;void&gt; setParameters (optionanl RTCRtpParameters parameters);
    void                stop ();
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCRtpSender" data-dfn-for=
          "RTCRtpSender" class="constructors">
            <dt><code>RtpReceiver</code></dt>
            <dd>
	      TODO
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCRtpReceiver" data-dfn-for=
          "RTCRtpReceiver" class="methods">
            <dt><code>setTransport</code></dt>
            <dd>
              <p>TODO</p>
            </dd>
            <dt><code>setParameters</code></dt>
            <dd>
              <p>TODO</p>
            </dd>
            <dt><code>stop</code></dt>
            <dd>
              <p>TODO</p>
            </dd>
          </dl>
	</section>
      </div>
    </section>
    <section>
      <div>
	<h3>RTCRtpParameters dictionary changes</h3>
	<p>TODO: Specify these are additions and everything is settable</p>
        <pre class="idl">dictionary RTCRtpParameters {
    DOMString mid;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpParameters</a> Members</h2>
          <dl data-link-for="RTCRtpParameters" data-dfn-for="RTCRtpParameters"
          class="dictionary-members">
            <dt><dfn><code>mid</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>TODO</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
	<h3>RTCRtpFecParameters dictionary changes</h3>
	<p>TODO: Specify these are additions and everything is settable</p>
        <pre class="idl">dictionary RTCRtpFecParameters {
    DOMString mechanism;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpFecParameters</a>
          Members</h2>
          <dl data-link-for="RTCRtpFecParameters" data-dfn-for=
          "RTCRtpFecParameters" class="dictionary-members">
            <dt><dfn><code>mechanism</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>TODO</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
	<h3>RTCRtcpParameters dictionary changes</h3>
	<p>TODO: Specify these are additions and everything is settable</p>
        <pre class="idl">dictionary RTCRtcpParameters {
     unsigned long ssrc;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtcpParameters</a>
          Members</h2>
          <dl data-link-for="RTCRtcpParameters" data-dfn-for=
          "RTCRtcpParameters" class="dictionary-members">
            <dt><dfn><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>TODO</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
	<h3>RTCRtpCodecParameters dictionary changes</h3>
	<p>TODO: Specify these are additions and everything is settable</p>
        <pre class="idl">dictionary RTCRtpCodecParameters {
    unsigned long             maxptime;
    unsigned long             ptime;
    sequence&lt;RTCRtcpFeedback&gt; rtcpFeedback;
    Dictionary                parameters;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpCodecParameters</a>
          Members</h2>
          <dl data-link-for="RTCRtpCodecParameters" data-dfn-for=
          "RTCRtpCodecParameters" class="dictionary-members">
            <dt><dfn><code>maxptime</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
	      TODO
            </dd>
            <dt><dfn><code>ptime</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
	      TODO
            </dd>
            <dt><dfn><code>rtcpFeedback</code></dfn> of type <span class=
            "idlMemberType"><a>sequence&lt;RTCRtcpFeedback&gt;</a></span></dt>
            <dd>
	      TODO
            </dd>
            <dt><dfn><code>parameters</code></dfn> of type <span class=
            "idlMemberType"><a>Dictionary</a></span></dt>
            <dd>
	      TODO
            </dd>
          </dl>
        </section>
      </div>
      <div>
****
	<p>*** This one is new *** </p>
        <pre class="idl">dictionary RTCRtcpFeedback {
    DOMString type;
    DOMString parameter;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtcpFeedback</a>
          Members</h2>
          <dl data-link-for="RTCRtcpFeedback" data-dfn-for=
          "RTCRtcpFeedback" class="dictionary-members">
            <dt><dfn><code>type</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>***</p>
            </dd>
          </dl>
        </section>
      </div>
      ****
    </section>
  <section>
    <h2>Transport API</h2>
    <section>
      <h3>RTCDtlsTransport Interface Extensions</h3>
      <div>
        <pre class="idl">
        [ Constructor (RTCIceTransport transport, sequence&lt;RTCCertificate&gt; certificates)]
partial interface RTCDtlsTransport {
    RTCDtlsParameters     getLocalParameters ();
    RTCDtlsParameters?    getRemoteParameters ();
    void                  start (RTCDtlsParameters remoteParameters);
    void                  stop ();

    readonly    attribute FrozenArray&lt;RTCCertificate&gt; certificates;
                attribute EventHandler onerror;

};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDtlsTransport" data-dfn-for="RTCDtlsTransport"
          class="attributes">
            <dt><dfn><code>certificates</code></dfn> of type <span class=
            "idlAttrType"><a>FrozenArray&lt;RTCCertificate&gt;</a></span>, readonly</dt>
            <dd>
              <p>***</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCDtlsTransport" data-dfn-for="RTCDtlsTransport"
          class="methods">
            <dt><dfn><code>getLocalParameters</code></dfn></dt>
            <dd>
              <p></p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;ArrayBuffer&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
	<p>***</p>
        <pre class="idl">dictionary RTCDtlsParameters {
    RTCDtlsRole                  role = "auto";
    sequence&lt;RTCDtlsFingerprint&gt; fingerprints;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDtlsParameters</a> Members</h2>
          <dl data-link-for="RTCDtlsParameters" data-dfn-for="RTCDtlsParameters"
          class="dictionary-members">
            <dt><dfn><code>role</code></dfn> of type <span class=
            "idlMemberType"><a>RTCDtlsRole</a></span></dt>
            <dd>
              <p>***</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
	<p>enum RTCDtlsRole</p>
        <pre class="idl">enum RTCDtlsRole {
    "auto",
    "client",
    "server"
};</pre>
	<p>***</p>
      </div>
      <div>
	<p>***</p>
        <pre class="idl">dictionary RTCDtlsFingerprint {
    DOMString algorithm;
    DOMString value;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDtlsFingerprint</a> Members</h2>
          <dl data-link-for="RTCDtlsFingerprint" data-dfn-for="RTCDtlsFingerprint"
          class="dictionary-members">
            <dt><dfn><code>algorithm</code></dfn> of type <span class=
            "idlMemberType"><a>value</a></span></dt>
            <dd>
              <p>***</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>RTCIceTransport Interface Extensions</h3>
      <p>***</p>
      <div>
        <pre class="idl">[ Constructor () ]
partial interface RTCIceTransport {
    readonly        attribute RTCIceGatherer?      iceGatherer;
    void                      start (RTCIceGatherer gatherer, RTCIceParameters remoteParameters, optional RTCIceRole role);
    void                      addRemoteCandidates (sequence&lt;RTCIceGatherCandidate&gt; remoteCandidate, optional bool complete);
    void                      stop ();
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport"
          class="attributes">
            <dt><code>iceGatherer</code> of type <span class=
            "idlAttrType"><a>RTCIceGatherer</a></span>, readonly</dt>
            <dd>
              <p></p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport"
          class="methods">
            <dt><dfn><code>getRemoteCandidates</code></dfn></dt>
            <dd>
              <p></p>
              <div>
                <em>***</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>***</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <div>
      <h3>RTCIceGatherer Interface</h3>
      <p>***</p>
      <div>
        <pre class="idl">[ Constructor () ]
interface RTCIceGatherer {
    readonly        attribute RTCIceGatheringState state;
    RTCIceParameters          getLocalParameters ();
    sequence&lt;RTCIceCandidate&gt; getLocalCandidates ();
    void                      start (optional RTCIceGatherOptions options);
    void                      stop ();
                    attribute EventHandler        onstatechange;
                    attribute EventHandler        onlocalcandidatesadded;
                    attribute EventHandler        onerror;
};</pre>

        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIceGatherer" data-dfn-for="RTCIceGatherer"
          class="attributes">
            <dt><code>state</code> of type <span class=
            "idlAttrType"><a>RTCIceGather</a></span>, readonly</dt>
            <dd>
              <p></p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCIceGatherer" data-dfn-for="RTCIceGatherer"
          class="methods">
            <dt><dfn><code>getLocalParameters</code></dfn></dt>
            <dd>
              <p></p>
              <div>
                <em>***</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>***</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  <section>
    <h2>Peer-to-peer Data API</h2>
    <p>The Peer-to-peer Data API lets a web application send and receive
    generic application data peer-to-peer. The API for sending and receiving
    data models the behavior of WebSockets [[WEBSOCKETS-API]].</p>
    <section>
      <h3>RTCPeerConnection Interface Extensions</h3>
      <p>The Peer-to-peer data API extends the
      <code><a>RTCPeerConnection</a></code> interface as described below.</p>
      <div>
        <pre class="idl">partial interface RTCPeerConnection {
    readonly        attribute RTCSctpTransport? sctp;
    RTCDataChannel createDataChannel ([TreatNullAs=EmptyString] USVString label, optional RTCDataChannelInit dataChannelDict);
                    attribute EventHandler      ondatachannel;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="attributes">
            <dt><dfn><code>sctp</code></dfn> of type <span class=
            "idlAttrType"><a>RTCSctpTransport</a></span>, readonly ,
            nullable</dt>
            <dd>
              <p>The SCTP transport over which SCTP data is sent and received.
              If SCTP has not been negotiated, the value is null.</p>
            </dd>
            <dt><dfn><code>ondatachannel</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>datachannel</a></code>.</dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="methods">
            <dt><code>createDataChannel</code></dt>
            <dd>
              <p>Creates a new <code><a>RTCDataChannel</a></code> object with
              the given label. The <code><a>RTCDataChannelInit</a></code>
              dictionary can be used to configure properties of the underlying
              channel such as <!--priority and--> data reliability.</p>
              <p>When the <dfn id=
              "dom-peerconnection-createdatachannel"><code>createDataChannel</code></dfn>
              method is invoked, the user agent MUST run the following
              steps.</p>
              <ol>
                <li>
                  <p>Let <var>connection</var> be the
                  <code><a>RTCPeerConnection</a></code> object on which the
                  method is invoked.</p>
                </li>
                <li>
                  <p>If <var>connection</var>'s [[<a>isClosed</a>]] slot is
                  <code>true</code>, throw an <code>InvalidStateError</code>
                  exception and abort these steps.</p>
                </li>
                <li>
                  <p>Let <var>channel</var> be a newly created
                  <code><a>RTCDataChannel</a></code> object.</p>
                </li>
                <li>
                  <p>Initialize <var>channel</var>'s <code><a data-for=
                  "RTCDataChannel">label</a></code> attribute to the value of
                  the first argument.</p>
                </li>
                <li>
                  <p>If the second (dictionary) argument is present, set
                  <var>channel</var>'s <code><a data-for=
                  "RTCDataChannel">ordered</a></code>, <code><a data-for=
                  "RTCDataChannel">maxPacketLifeTime</a></code>,
                  <code><a data-for="RTCDataChannel">maxRetransmits</a></code>,
                  <code><a data-for="RTCDataChannel">protocol</a></code>,
                  <code><a data-for="RTCDataChannel">negotiated</a></code> and
                  <code><a data-for="RTCDataChannel">id</a></code> attributes
                  to the values of their corresponding dictionary members (if
                  present in the dictionary).</p>
                </li>
                <li>If <code>negotiated</code> is false and <code>label</code>
                is longer than 65535 bytes long, <a href=
                "http://heycam.github.io/webidl/#dfn-throw">throw</a> a <code>
                  TypeError</code>.
                </li>
                <li>If <code>negotiated</code> is false and
                <code>protocol</code> is longer than 65535 bytes long,
                  <a href="http://heycam.github.io/webidl/#dfn-throw">throw</a>
                  a <code>TypeError</code>.
                </li>
                <li>
                  <p>If both the <code><a data-for=
                  "RTCDataChannel">maxPacketLifeTime</a></code> and
                  <code><a data-for="RTCDataChannel">maxRetransmits</a></code>
                  attributes are set (not null), then throw a
                  <code>SyntaxError</code> exception and abort these steps.</p>
                </li>
                <li>
                  <p>If an attribute, either <code><a data-for=
                  "RTCDataChannel">maxPacketLifeTime</a></code> or
                  <code><a data-for="RTCDataChannel">maxRetransmits</a></code>,
                  has been set to indicate unreliable mode, and that value
                  exceeds the maximum value supported by the user agent, the
                  value MUST be set to the user agents maximum value.</p>
                </li>
                <li>
                  <p>If <code><a data-for="RTCDataChannel">id</a></code>
                  attribute is uninitialized (not set via the dictionary),
                  initialize it to a value generated by the user agent,
                  according to the WebRTC DataChannel Protocol specification,
                  and skip to the next step. Otherwise, if the value of the
                  <code><a data-for="RTCDataChannel">id</a></code> attribute is
                  taken by an existing <code><a>RTCDataChannel</a></code>,
                  throw a <code>ResourceInUse</code> exception and abort these
                  steps.</p>
                </li>
                <li>
                  <p>Return <var>channel</var> and continue the following steps
                  in the background.</p>
                </li>
                <li>
                  <p>Create <var>channel</var>'s associated <a>underlying data
                  transport</a> and configure it according to the relevant
                  properties of <var>channel</var>.</p>
                </li>
                <li>
                  <p>If <var>channel</var> was the first RTCDataChannel created
                  on <var>connection</var>, mark <var>connection</var> as
                  needing negotiation.</p>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">label</td>
                    <td class="prmType"><code>USVString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">dataChannelDict</td>
                    <td class="prmType"><code>RTCDataChannelInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>RTCDataChannel</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <section>
        <h3>RTCSctpTransport Interface</h3>
        <p>The <code><a>RTCSctpTransport</a></code> interface allows an
        application access to information about the SCTP data channels tied to
        a particular SCTP association.</p>
        <div>
          <pre class="idl">interface RTCSctpTransport {
    readonly        attribute RTCDtlsTransport transport;
    readonly        attribute unsigned long    maxMessageSize;
};</pre>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCSctpTransport" data-dfn-for=
            "RTCSctpTransport" class="attributes">
              <dt><dfn><code>transport</code></dfn> of type <span class=
              "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly</dt>
              <dd>
                <p>The transport over which all SCTP packets for data channels
                will be sent and received.</p>
              </dd>
              <dt><dfn><code>maxMessageSize</code></dfn> of type <span class=
              "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
              <dd>
                <p>The maximum size of data that can be passed to
                <code><a>RTCDataChannel</a></code>'s <code><a data-for=
                "RTCDataChannel">send()</a></code> method.</p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h3>RTCDataChannel</h3>
      <p>The <code><a>RTCDataChannel</a></code> interface represents a
      bi-directional data channel between two peers. A
      <code><a>RTCDataChannel</a></code> is created via a factory method on an
      <code><a>RTCPeerConnection</a></code> object. The messages sent between
      the browsers are described in [[!RTCWEB-DATA]] and
      [[!RTCWEB-DATA-PROTOCOL]].</p>
      <p>There are two ways to establish a connection with
      <code><a>RTCDataChannel</a></code>. The first way is to simply create a
      <code><a>RTCDataChannel</a></code> at one of the peers with the
      <code><a data-for="RTCDataChannelInit">negotiated</a></code>
      <code><a>RTCDataChannelInit</a></code> dictionary member unset or set to
      its default value false. This will announce the new channel in-band and
      trigger a <code><a>RTCDataChannelEvent</a></code> with the corresponding
      <code><a>RTCDataChannel</a></code> object at the other peer. The second
      way is to let the application negotiate the
      <code><a>RTCDataChannel</a></code>. To do this, create a
      <code><a>RTCDataChannel</a></code> object with the <code><a data-for=
      "RTCDataChannelInit">negotiated</a></code>
      <code><a>RTCDataChannelInit</a></code> dictionary member set to true, and
      signal out-of-band (e.g. via a web server) to the other side that it
      SHOULD create a corresponding <code><a>RTCDataChannel</a></code> with the
      <code><a data-for="RTCDataChannelInit">negotiated</a></code>
      <code><a>RTCDataChannelInit</a></code> dictionary member set to true and
      the same <code><a data-for="RTCDataChannel">id</a></code>. This will
      connect the two separately created <code><a>RTCDataChannel</a></code>
      objects. The second way makes it possible to create channels with
      asymmetric properties and to create channels in a declarative way by
      specifying matching <code><a data-for=
      "RTCDataChannelInit">id</a></code>s.</p>
      <p>Each <code><a>RTCDataChannel</a></code> has an associated
      <dfn data-lt="data transport">underlying data transport</dfn> that is
      used to transport actual data to the other peer. The transport properties
      of the <a>underlying data transport</a>, such as in order delivery
      settings and reliability mode, are configured by the peer as the channel
      is created. The properties of a channel cannot change after the channel
      has been created. The actual wire protocol between the peers is specified
      by the WebRTC DataChannel Protocol specification [[RTCWEB-DATA]].</p>
      <p>A <code><a>RTCDataChannel</a></code> can be configured to operate in
      different reliability modes. A reliable channel ensures that the data is
      delivered at the other peer through retransmissions. An unreliable
      channel is configured to either limit the number of retransmissions (
      <code><a data-for="RTCDataChannelInit">maxRetransmits</a></code> ) or set
      a time during which transmissions (including retransmissions) are allowed
      ( <code><a data-for="RTCDataChannelInit">maxPacketLifeTime</a></code> ).
      These properties can not be used simultaneously and an attempt to do so
      will result in an error. Not setting any of these properties results in a
      reliable channel.</p>
      <p>A <code><a>RTCDataChannel</a></code>, created with <code><a data-for=
      "RTCPeerConnection">createDataChannel</a></code> or dispatched via a
      <code><a>RTCDataChannelEvent</a></code>, MUST initially be in the
      <code>connecting</code> state. When the
      <code><a>RTCDataChannel</a></code> object's <a>underlying data
      transport</a> is ready, the user agent MUST <a>announce the
      <code>RTCDataChannel</code> as open</a>.</p>
      <p>When the user agent is to <dfn data-lt=
      "announce the rtcdatachannel as open" id=
      "announce-datachannel-open">announce a <code>RTCDataChannel</code> as
      open</dfn>, the user agent MUST queue a task to run the following
      steps:</p>
      <ol>
        <li>
          <p>If the associated <code><a>RTCPeerConnection</a></code> object's
          [[<a>isClosed</a>]] slot is <code>true</code>, abort these steps.</p>
        </li>
        <li>
          <p>Let <var>channel</var> be the <code><a>RTCDataChannel</a></code>
          object to be announced.</p>
        </li>
        <li>
          <p>Set <var>channel</var>'s <code><a data-for=
          "RTCDataChannel">readyState</a></code> attribute to
          <code>open</code>.</p>
        </li>
        <li>
          <p>Fire a simple event named <code><a>open</a></code> at
          <var>channel</var>.</p>
        </li>
      </ol>
      <p>When an <a>underlying data transport</a> is to be announced (the other
      peer created a channel with <code><a data-for=
      "RTCDataChannelInit">negotiated</a></code> unset or set to false), the
      user agent of the peer that did not initiate the creation process MUST
      queue a task to run the following steps:</p>
      <ol>
        <li>
          <p>If the associated <code><a>RTCPeerConnection</a></code> object's
          [[<a>isClosed</a>]] slot is <code>true</code>, abort these steps.</p>
        </li>
        <li>
          <p>Let <var>channel</var> be a newly created
          <code><a>RTCDataChannel</a></code> object.</p>
        </li>
        <li>
          <p>Let <var>configuration</var> be an information bundle received
          from the other peer as a part of the process to establish the
          <a>underlying data transport</a> described by the WebRTC DataChannel
          Protocol specification [[!RTCWEB-DATA-PROTOCOL]].</p>
        </li>
        <li>
          <p>Initialize <var>channel</var>'s <code><a data-for=
          "RTCDataChannel">label</a></code>, <code><a data-for=
          "RTCDataChannel">ordered</a></code>, <code><a data-for=
          "RTCDataChannel">maxPacketLifeTime</a></code>, <code><a data-for=
          "RTCDataChannel">maxRetransmits</a></code>, <code><a data-for=
          "RTCDataChannel">protocol</a></code>, <code><a data-for=
          "RTCDataChannel">negotiated</a></code> and <code><a data-for=
          "RTCDataChannel">id</a></code> attributes to their corresponding
          values in <var>configuration</var>.</p>
        </li>
        <li>
          <p>Set <var>channel</var>'s <code><a data-for=
          "RTCDataChannel">readyState</a></code> attribute to
          <code>connecting</code>.</p>
        </li>
        <li>
          <p><a>Fire a datachannel event</a> named
          <code><a>datachannel</a></code> with <var>channel</var> at the
          <code><a>RTCPeerConnection</a></code> object.</p>
        </li>
      </ol>
      <p>An <code><a>RTCDataChannel</a></code> object's <a>underlying data
      transport</a> may be torn down in a non-abrupt manner by running the
      <dfn id="data-transport-closing-procedure">closing procedure</dfn>. When
      that happens the user agent MUST, unless the procedure was initiated by
      the <code><a data-for="RTCDataChannel">close</a></code> method, queue a
      task that sets the object's <code><a data-for=
      "RTCDataChannel">readyState</a></code> attribute to <code>closing</code>.
      This will eventually render the <a>data transport</a> <a>closed</a>.</p>
      <p>When a <code><a>RTCDataChannel</a></code> object's <a>underlying data
      transport</a> has been <dfn id="data-transport-closed">closed</dfn>, the
      user agent MUST queue a task to run the following steps:</p>
      <ol>
        <li>
          <p>Let <var>channel</var> be the <code><a>RTCDataChannel</a></code>
          object whose <a data-lt="data transport">transport</a> was
          closed.</p>
          <div class="issue">
            The data transport protocol will specify what happens to, e.g.
            buffered data, when the data transport is closed.
          </div>
        </li>
        <li>
          <p>Set <var>channel</var>'s <code><a data-for=
          "RTCDataChannel">readyState</a></code> attribute to
          <code>closed</code>.</p>
        </li>
        <li>
          <p>If the <a data-lt="data transport">transport</a> was closed
          <dfn id="data-transport-closed-error">with an error</dfn>, fire an
          NetworkError event at <var>channel</var>.</p>
        </li>
        <li>
          <p>Fire a simple event named <code title=
          "event-RTCDataChannel-close"><a>close</a></code> at
          <var>channel</var>.</p>
        </li>
      </ol>
      <div>
        <pre class="idl">interface RTCDataChannel : EventTarget {
    readonly        attribute USVString           label;
    readonly        attribute boolean             ordered;
    readonly        attribute unsigned short?     maxPacketLifeTime;
    readonly        attribute unsigned short?     maxRetransmits;
    readonly        attribute USVString           protocol;
    readonly        attribute boolean             negotiated;
    readonly        attribute unsigned short      id;
    readonly        attribute RTCDataChannelState readyState;
    readonly        attribute unsigned long       bufferedAmount;
                    attribute unsigned long       bufferedAmountLowThreshold;
                    attribute EventHandler        onopen;
                    attribute EventHandler        onbufferedamountlow;
                    attribute EventHandler        onerror;
                    attribute EventHandler        onclose;
    void close ();
                    attribute EventHandler        onmessage;
                    attribute DOMString           binaryType;
    void send (USVString data);
    void send (Blob data);
    void send (ArrayBuffer data);
    void send (ArrayBufferView data);
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDataChannel" data-dfn-for="RTCDataChannel"
          class="attributes">
            <dt><code>label</code> of type <span class=
            "idlAttrType"><a>USVString</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-datachannel-label"><code>label</code></dfn>
              attribute represents a label that can be used to distinguish this
              <code><a>RTCDataChannel</a></code> object from other
              <code><a>RTCDataChannel</a></code> objects. Scripts are allowed
              to create multiple <code><a>RTCDataChannel</a></code> objects
              with the same label. The attribute MUST return the value to which
              it was set when the <code><a>RTCDataChannel</a></code> object was
              created.</p>
            </dd>
            <dt><code>ordered</code> of type <span class=
            "idlAttrType"><a>boolean</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-ordered"><code>ordered</code></dfn> attribute
              returns true if the <code><a>RTCDataChannel</a></code> is
              ordered, and false if other of order delivery is allowed. The
              attribute MUST be initialized to true by default and MUST return
              the value to which it was set when the
              <code><a>RTCDataChannel</a></code> was created.</p>
            </dd>
            <dt><code>maxPacketLifeTime</code> of type <span class=
            "idlAttrType"><a>unsigned short</a></span>, readonly ,
            nullable</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-maxpacketlifetime"><code>maxPacketLifeTime</code></dfn>
              attribute returns the length of the time window (in milliseconds)
              during which transmissions and retransmissions may occur in
              unreliable mode, or null if unset. The attribute MUST be
              initialized to null by default and MUST return the value to which
              it was set when the <code><a>RTCDataChannel</a></code> was
              created.</p>
            </dd>
            <dt><code>maxRetransmits</code> of type <span class=
            "idlAttrType"><a>unsigned short</a></span>, readonly ,
            nullable</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-maxretransmits"><code>maxRetransmits</code></dfn>
              attribute returns the maximum number of retransmissions that are
              attempted in unreliable mode, or null if unset. The attribute
              MUST be initialized to null by default and MUST return the value
              to which it was set when the <code><a>RTCDataChannel</a></code>
              was created.</p>
            </dd>
            <dt><code>protocol</code> of type <span class=
            "idlAttrType"><a>USVString</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-protocol"><code>protocol</code></dfn> attribute
              returns the name of the sub-protocol used with this
              <code><a>RTCDataChannel</a></code> if any, or the empty string
              otherwise. The attribute MUST be initialized to the empty string
              by default and MUST return the value to which it was set when the
              <code><a>RTCDataChannel</a></code> was created.</p>
            </dd>
            <dt><code>negotiated</code> of type <span class=
            "idlAttrType"><a>boolean</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-negotiated"><code>negotiated</code></dfn>
              attribute returns true if this <code><a>RTCDataChannel</a></code>
              was negotiated by the application, or false otherwise. The
              attribute MUST be initialized to false by default and MUST return
              the value to which it was set when the
              <code><a>RTCDataChannel</a></code> was created.</p>
            </dd>
            <dt><dfn><code>id</code></dfn> of type <span class=
            "idlAttrType"><a>unsigned short</a></span>, readonly</dt>
            <dd>
              <p>The <code>id</code> attribute returns the id for this
              <code><a>RTCDataChannel</a></code>. The id was either assigned by
              the user agent at channel creation time or selected by the
              script. The attribute MUST return the value to which it was set
              when the <code><a>RTCDataChannel</a></code> was created.</p>
            </dd>
            <dt><code>readyState</code> of type <span class=
            "idlAttrType"><a>RTCDataChannelState</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-readystate"><code>readyState</code></dfn>
              attribute represents the state of the <code>RTCDataChannel</code>
              object. It MUST return the value to which the user agent last set
              it (as defined by the processing model algorithms).</p>
            </dd>
            <dt><code>bufferedAmount</code> of type <span class=
            "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-bufferedamount"><code>bufferedAmount</code></dfn>
              attribute MUST return the number of bytes of application data
              (UTF-8 text and binary data) that have been queued using
              <code><a data-for="RTCDataChannel">send()</a></code> but that, as
              of the last time the event loop started executing a task, had not
              yet been transmitted to the network. (This thus includes any text
              sent during the execution of the current task, regardless of
              whether the user agent is able to transmit text asynchronously
              with script execution.) This does not include framing overhead
              incurred by the protocol, or buffering done by the operating
              system or network hardware. If the channel is closed, this
              attribute's value will only increase with each call to the
              <code><a data-for="RTCDataChannel">send()</a></code> method (the
              attribute does not reset to zero once the channel closes).</p>
            </dd>
            <dt><code>bufferedAmountLowThreshold</code> of type <span class=
            "idlAttrType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The <dfn><code>bufferedAmountLowThreshold</code></dfn>
              attribute sets the threshold at which the <code><a data-for=
              "RTCDataChannel">bufferedAmount</a></code> is considered to be
              low. When the <code><a data-for=
              "RTCDataChannel">bufferedAmount</a></code> decreases from above
              this threshold to equal or below it, the <code title=
              "event-RTCDataChannel-bufferedamountlow"><a>bufferedamountlow</a></code>
              event fires. The <code><a data-for=
              "RTCDataChannel">bufferedAmountLowThreshold</a></code> is
              initially zero on each new <code><a>RTCDataChannel</a></code>,
              but the application may change its value at any time.</p>
            </dd>
            <dt><dfn><code>onopen</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>open</a></code>.</dd>
            <dt><dfn><code>onbufferedamountlow</code></dfn> of type
            <span class="idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>bufferedamountlow</a></code>.</dd>
            <dt><dfn><code>onerror</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>error</a></code>.</dd>
            <dt><dfn><code>onclose</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>close</a></code>.</dd>
            <dt><dfn><code>onmessage</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>The event type of this event handler is
            <code><a>message</a></code>.</dd>
            <dt><code>binaryType</code> of type <span class=
            "idlAttrType"><a>DOMString</a></span></dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-binarytype"><code>binaryType</code></dfn>
              attribute MUST, on getting, return the value to which it was last
              set. On setting, the user agent MUST set the IDL attribute to the
              new value. When a <code><a>RTCDataChannel</a></code> object is
              created, the <code><a data-for=
              "RTCDataChannel">binaryType</a></code> attribute MUST be
              initialized to the string "<code>blob</code>".</p>
              <p>This attribute controls how binary data is exposed to scripts.
              See the [[WEBSOCKETS-API]] for more information.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCDataChannel" data-dfn-for="RTCDataChannel"
          class="methods">
            <dt><code>close</code></dt>
            <dd>
              <p>Closes the <code><a>RTCDataChannel</a></code>. It may be
              called regardless of whether the
              <code><a>RTCDataChannel</a></code> object was created by this
              peer or the remote peer.</p>
              <p>When the <dfn>close</dfn> method is called, the user agent
              MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>channel</var> be the
                  <code><a>RTCDataChannel</a></code> object which is about to
                  be closed.</p>
                </li>
                <li>
                  <p>If <var>channel</var>'s <code><a data-for=
                  "RTCDataChannel">readyState</a></code> is
                  <code>closing</code> or <code>closed</code>, then abort these
                  steps.</p>
                </li>
                <li>
                  <p>Set <var>channel</var>'s <code><a data-for=
                  "RTCDataChannel">readyState</a></code> attribute to
                  <code>closing</code>.</p>
                </li>
                <li>
                  <p>If the <code><a>closing procedure</a></code> has not
                  started yet, start it.</p>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code><a data-for=
              "RTCDataChannel">send()</a></code> algorithm with argument type
              <code>string</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>USVString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn data-lt="send!overload-1" data-lt-nodefault=
            "true"><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code><a data-for=
              "RTCDataChannel">send()</a></code> algorithm with argument type
              <code>Blob</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>Blob</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn data-lt="send!overload-2" data-lt-nodefault=
            "true"><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code><a data-for=
              "RTCDataChannel">send()</a></code> algorithm with argument type
              <code>ArrayBuffer</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>ArrayBuffer</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn data-lt="send!overload-3" data-lt-nodefault=
            "true"><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code><a data-for=
              "RTCDataChannel">send()</a></code> algorithm with argument type
              <code>ArrayBufferView</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>ArrayBufferView</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCDataChannelInit {
             boolean        ordered = true;
             unsigned short maxPacketLifeTime;
             unsigned short maxRetransmits;
             USVString      protocol = "";
             boolean        negotiated = false;
             unsigned short id;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDataChannelInit</a> Members</h2>
          <dl data-link-for="RTCDataChannelInit" data-dfn-for=
          "RTCDataChannelInit" class="dictionary-members">
            <dt><dfn><code>ordered</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to
            <code>true</code></dt>
            <dd>
              <p>If set to false, data is allowed to be delivered out of order.
              The default value of true, guarantees that data will be delivered
              in order.</p>
            </dd>
            <dt><dfn><code>maxPacketLifeTime</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>Limits the time during which the channel will transmit or
              retransmit data if not acknowledged. This value may be clamped if
              it exceeds the maximum value supported by the user agent.</p>
            </dd>
            <dt><dfn><code>maxRetransmits</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>Limits the number of times a channel will retransmit data if
              not successfully delivered. This value may be clamped if it
              exceeds the maximum value supported by the user agent.</p>
            </dd>
            <dt><dfn><code>protocol</code></dfn> of type <span class=
            "idlMemberType"><a>USVString</a></span>, defaulting to
            <code>""</code></dt>
            <dd>
              <p>Subprotocol name used for this channel.</p>
            </dd>
            <dt><dfn><code>negotiated</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to
            <code>false</code></dt>
            <dd>
              <p>The default value of false tells the user agent to announce
              the channel in-band and instruct the other peer to dispatch a
              corresponding <code><a>RTCDataChannel</a></code> object. If set
              to true, it is up to the application to negotiate the channel and
              create a <code><a>RTCDataChannel</a></code> object with the same
              <code><a data-for="RTCDataChannel">id</a></code> at the other
              peer.</p>
            </dd>
            <dt><dfn><code>id</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>Overrides the default selection of id for this channel.</p>
            </dd>
          </dl>
        </section>
      </div>
      <p>The <dfn><code>send()</code></dfn> method is overloaded to handle
      different data argument types. When any version of the method is called,
      the user agent MUST run the following steps:</p>
      <ol>
        <li>
          <p>Let <var>channel</var> be the <code><a>RTCDataChannel</a></code>
          object on which data is to be sent.</p>
        </li>
        <li>
          <p>If <var>channel</var>'s <a data-for=
          "RTCDataChannel"><code>readyState</code></a> attribute is
          <code>connecting</code>, throw an <code>InvalidStateError</code>
          exception and abort these steps.</p>
        </li>
        <li>
          <p>Execute the sub step that corresponds to the type of the methods
          argument:</p>
          <ul>
            <li>
              <p><code>string</code> object:</p>
              <p>Let <var>data</var> be the object and increase the
              <code><a data-for="RTCDataChannel">bufferedAmount</a></code>
              attribute by the number of bytes needed to express
              <var>data</var> as UTF-8.</p>
            </li>
            <li>
              <p><code>Blob</code> object:</p>
              <p>Let <var>data</var> be the raw data represented by the
              <code>Blob</code> object and increase the <code><a data-for=
              "RTCDataChannel">bufferedAmount</a></code> attribute by the size
              of data, in bytes.</p>
            </li>
            <li>
              <p><code>ArrayBuffer</code> object:</p>
              <p>Let <var>data</var> be the data stored in the buffer described
              by the <code>ArrayBuffer</code> object and increase the
              <code><a data-for="RTCDataChannel">bufferedAmount</a></code>
              attribute by the length of the <code>ArrayBuffer</code> in
              bytes.</p>
            </li>
            <li>
              <p><code>ArrayBufferView</code> object:</p>
              <p>Let <var>data</var> be the data stored in the section of the
              buffer described by the <code>ArrayBuffer</code> object that the
              <code>ArrayBufferView</code> object references and increase the
              <code><a data-for="RTCDataChannel">bufferedAmount</a></code>
              attribute by the length of the <code>ArrayBufferView</code> in
              bytes.</p>
            </li>
          </ul>
        </li>
        <li>
          <p>If <var>channel</var>'s <a>underlying data transport</a> is not
          established yet, or if the <code><a>closing procedure</a></code> has
          started, then abort these steps.</p>
        </li>
        <li>
          <p>Attempt to send <var>data</var> on <var>channel</var>'s
          <a>underlying data transport</a>; if the data cannot be sent, e.g.
          because it would need to be buffered but the buffer is full, the user
          agent MUST abruptly <a>close</a> <var>channel</var>'s <a>underlying
          data transport</a> <a>with an error</a>.</p>
        </li>
      </ol>
      <div>
        <pre class="idl">enum RTCDataChannelState {
    "connecting",
    "open",
    "closing",
    "closed"
};</pre>
        <table data-link-for="RTCDataChannelState" data-dfn-for=
        "RTCDataChannelState" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>connecting</code></dfn></td>
              <td>
                <p>The user agent is attempting to establish the <a>underlying
                data transport</a>. This is the initial state of a
                <code><a>RTCDataChannel</a></code> object created with
                <code><a data-for=
                "RTCPeerConnection">createDataChannel</a></code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code>open</code></dfn></td>
              <td>
                <p>The <a>underlying data transport</a> is established and
                communication is possible. This is the initial state of a
                <code><a>RTCDataChannel</a></code> object dispatched as a part
                of a <code><a>RTCDataChannelEvent</a></code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code>closing</code></dfn></td>
              <td>
                <p>The <code><a data-lt=
                "closing procedure">procedure</a></code> to close down the
                <a>underlying data transport</a> has started.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code>closed</code></dfn></td>
              <td>
                <p>The <a>underlying data transport</a> has been
                <code><a>closed</a></code> or could not be established.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section>
      <h3>RTCDataChannelEvent</h3>
      <p>The <code><a>datachannel</a></code> event uses the
      <code><a>RTCDataChannelEvent</a></code> interface.</p>
      <p><dfn id="fire-a-datachannel-event" data-lt=
      "fire a datachannel event">Firing a datachannel event named
      <var>e</var></dfn> with a <code><a>RTCDataChannel</a></code>
      <var>channel</var> means that an event with the name <var>e</var>, which
      does not bubble (except where otherwise stated) and is not cancelable
      (except where otherwise stated), and which uses the
      <code><a>RTCDataChannelEvent</a></code> interface with the
      <code><a data-for="RTCDataChannelEvent">channel</a></code> attribute set
      to <var>channel</var>, MUST be created and dispatched at the given
      target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCDataChannelEventInit eventInitDict)]
interface RTCDataChannelEvent : Event {
    readonly        attribute RTCDataChannel channel;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCDataChannelEvent" data-dfn-for=
          "RTCDataChannelEvent" class="constructors">
            <dt><dfn><code>RTCDataChannelEvent</code></dfn></dt>
            <dd>
              readonly attribute RTCDataChannel channel
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType">
                    <code>RTCDataChannelEventInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDataChannelEvent" data-dfn-for=
          "RTCDataChannelEvent" class="attributes">
            <dt><code>channel</code> of type <span class=
            "idlAttrType"><a>RTCDataChannel</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannelevent-channel"><code>channel</code></dfn>
              attribute represents the <code><a>RTCDataChannel</a></code>
              object associated with the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCDataChannelEventInit : EventInit {
             RTCDataChannel channel;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDataChannelEventInit</a>
          Members</h2>
          <dl data-link-for="RTCDataChannelEventInit" data-dfn-for=
          "RTCDataChannelEventInit" class="dictionary-members">
            <dt><dfn><code>channel</code></dfn> of type <span class=
            "idlMemberType"><a>RTCDataChannel</a></span></dt>
            <dd>
              <p class="issue">TODO</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>Garbage Collection</h3>
      <p>A <code><a>RTCDataChannel</a></code> object MUST not be garbage
      collected if its</p>
      <ul>
        <li>
          <p><code><a data-for="RTCDataChannel">readyState</a></code> is
          <code>connecting</code> and at least one event listener is registered
          for <code>open</code> events, <code>message</code> events,
          <code>error</code> events, or <code>close</code> events.</p>
        </li>
        <li>
          <p><code><a data-for="RTCDataChannel">readyState</a></code> is
          <code>open</code> and at least one event listener is registered for
          <code>message</code> events, <code>error</code> events, or
          <code>close</code> events.</p>
        </li>
        <li>
          <p><code><a data-for="RTCDataChannel">readyState</a></code> is
          <code>closing</code> and at least one event listener is registered
          for <code>error</code> events, or <code>close</code> events.</p>
        </li>
        <li>
          <p><a>underlying data transport</a> is established and data is queued
          to be transmitted.</p>
        </li>
      </ul>
    </section>
  </section>
  <section>
    <h3>Peer-to-peer DTMF</h3>
    <p>This section describes an interface on <code><a>RTCRtpSender</a></code>
    to send DTMF (phone keypad) values across an
    <code><a>RTCPeerConnection</a></code>. Details of how DTMF is sent to the
    other peer are described in [[!RTCWEB-AUDIO]].</p>
    <section>
      <h3>RTCRtpSender Interface Extensions</h3>
      <p>The Peer-to-peer DTMF API extends the <code><a>RTCRtpSender</a></code>
      interface as described below.</p>
      <div>
        <pre class="idl">partial interface RTCRtpSender {
    readonly        attribute RTCDTMFSender? dtmf;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class=
          "attributes">
            <dt><code>dtmf</code> of type <span class=
            "idlAttrType"><a>RTCDTMFSender</a></span>, readonly , nullable</dt>
            <dd>
              <p>The <dfn>dtmf</dfn> attribute returns a RTCDTMFSender which
              can be used to send DTMF. A null value indicates that this
              RTCRtpSender cannot send DTMF.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h4>RTCDTMFSender</h4>
      <div>
        <pre class="idl">
interface RTCDTMFSender : EventTarget {
    void insertDTMF (DOMString tones, optional unsigned long duration = 100, optional unsigned long interToneGap = 70);
                    attribute EventHandler ontonechange;
    readonly        attribute DOMString    toneBuffer;
    readonly        attribute unsigned long         duration;
    readonly        attribute unsigned long         interToneGap;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDTMFSender" data-dfn-for="RTCDTMFSender" class=
          "attributes">
            <dt><dfn><code>ontonechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>The event type of this event handler is
              <code><a>tonechange</a></code>.</p>
            </dd>
            <dt><code>toneBuffer</code> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-RTCDTMFSender-tonebuffer"><code>toneBuffer</code></dfn>
              attribute MUST return a list of the tones remaining to be played
              out. For the syntax, content, and interpretation of this list,
              see <code><a>insertDTMF</a></code>.</p>
            </dd>
            <dt><code>duration</code> of type <span class=
            "idlAttrType"><a>long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-RTCDTMFSender-duration"><code>duration</code></dfn>
              attribute MUST return the current tone duration value. This value
              will be the value last set via the <code><a>insertDTMF</a></code>
              method, or the default value of 100 ms if
              <code><a>insertDTMF</a></code> was called without specifying the
              duration.</p>
            </dd>
            <dt><code>interToneGap</code> of type <span class=
            "idlAttrType"><a>long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id=
              "dom-RTCDTMFSender-intertonegap"><code>interToneGap</code></dfn>
              attribute MUST return the current value of the between-tone gap.
              This value will be the value last set via the
              <code><a>insertDTMF</a></code> method, or the default value of 70
              ms if <code><a>insertDTMF</a></code> was called without
              specifying the interToneGap.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCDTMFSender" data-dfn-for="RTCDTMFSender" class=
          "methods">
            <dt><code>insertDTMF</code></dt>
            <dd>
              <p>An <code><a>RTCDTMFSender</a></code> object's <dfn id=
              "dom-RTCDTMFSender-insertDTMF"><code>insertDTMF</code></dfn>
              method is used to send DTMF tones.</p>
              <p>The tones parameter is treated as a series of characters. The
              characters 0 through 9, A through D, #, and * generate the
              associated DTMF tones. The characters a to d (normalized to 
              uppercase on entry) are equivalent to A to D.
              As noted in [[RTCWEB-AUDIO]] Section 3, support for the
              characters 0 through 9, A through D, #, and * are required.
              The character ',' MUST be supported, and indicates a delay
              of 2 seconds before processing the next character in the tones
              parameter. All other characters (and only those other characters)
              MUST be considered <dfn id="dtmf-unrecognized">unrecognized</dfn>.</p>
              <p>The duration parameter indicates the duration in ms to use for
              each character passed in the tones parameters. The duration
              cannot be more than 8000 ms or less than 40 ms. The default
              duration is 100 ms for each tone.</p>
              <p>The interToneGap parameter indicates the gap between tones. The
              user agent clamps it to at least 30 ms. The default value is 70
              ms.</p>
              <p>The browser MAY increase the duration and interToneGap times
              to cause the times that DTMF start and stop to align with the
              boundaries of RTP packets but it MUST not increase either of them
              by more than the duration of a single RTP audio packet.</p>
              <p>When the <code><a>insertDTMF()</a></code> method is invoked,
              the user agent MUST run the following steps:</p>
              <ol>
                <li>If the <code>tones</code> argument contains any
                <a>unrecognized</a> characters, throw an
                <code>InvalidCharacterError</code> exception and abort these
                steps.
                </li>
                <li>Set the object's <code><a data-for=
                "RTCDTMFSender">toneBuffer</a></code> attribute to the value of
                the first argument, the <code><a data-for=
                "RTCDTMFSender">duration</a></code> attribute to the value of
                the second argument, and the <code><a data-for=
                "RTCDTMFSender">interToneGap</a></code> attribute to the value
                of the third argument.</li>
                <li>If <code><a data-for="RTCDTMFSender">toneBuffer</a></code>
                is an empty string, return.</li>
                <li>If the value of the <code><a data-for=
                "RTCDTMFSender">duration</a></code> attribute is less than 40,
                set it to 40. If, on the other hand, the value is greater than
                6000, set it to 6000.</li>
                <li>If the value of the <code><a data-for=
                "RTCDTMFSender">interToneGap</a></code> attribute is less than
                30, set it to 30.</li>
                <li>If a <em>Playout task</em> is scheduled to be run; abort
                these steps; otherwise queue a task that runs the following
                steps (<em>Playout task</em>):
                  <ol>
                    <li>If <code><a data-for=
                    "RTCDTMFSender">toneBuffer</a></code> is an empty string,
                    fire an event named <code><a>tonechange</a></code> with an
                    empty string at the <code><a>RTCDTMFSender</a></code>
                    object and abort these steps.</li>
                    <li>Remove the first character from <code><a data-for=
                    "RTCDTMFSender">toneBuffer</a></code> and let that
                    character be <var>tone</var>.</li>
                    <li>Start playout of <var>tone</var> for <code><a data-for=
                    "RTCDTMFSender">duration</a></code> ms on the associated
                    RTP media stream, using the appropriate codec.</li>
                    <li>Queue a task to be executed in <code><a data-for=
                    "RTCDTMFSender">duration</a></code> + <code><a data-for=
                    "RTCDTMFSender">interToneGap</a></code> ms from now that
                    runs the steps labelled <em>Playout task</em>.</li>
                    <li>Fire an event named <code><a>tonechange</a></code> with
                    a string consisting of <var>tone</var> at the
                    <code><a>RTCDTMFSender</a></code> object.</li>
                  </ol>
                </li>
              </ol>
              <p>Calling <code><a data-for=
              "RTCDTMFSender">insertDTMF</a></code> with an empty tones
              parameter can be used to cancel all tones queued to play after
              the currently playing tone.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">tones</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">duration</td>
                    <td class="prmType"><code>unsigned long = 100</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">interToneGap</td>
                    <td class="prmType"><code>unsigned long = 70</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>RTCDTMFToneChangeEvent</h3>
      <p>The <code><a>tonechange</a></code> event uses the
      <code><a>RTCDTMFToneChangeEvent</a></code> interface.</p>
      <p><dfn id="fire-a-tonechange-event" data-lt=
      "fire a tonechange event">Firing a tonechange event named
      <var>e</var></dfn> with a <code>DOMString</code> <var>tone</var> means
      that an event with the name <var>e</var>, which does not bubble (except
      where otherwise stated) and is not cancelable (except where otherwise
      stated), and which uses the <code><a>RTCDTMFToneChangeEvent</a></code>
      interface with the <code><a data-for=
      "RTCDTMFToneChangeEvent">tone</a></code> attribute set to
      <var>tone</var>, MUST be created and dispatched at the given target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCDTMFToneChangeEventInit eventInitDict)]
interface RTCDTMFToneChangeEvent : Event {
    readonly        attribute DOMString tone;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCDTMFToneChangeEvent" data-dfn-for=
          "RTCDTMFToneChangeEvent" class="constructors">
            <dt><dfn><code>RTCDTMFToneChangeEvent</code></dfn></dt>
            <dd>
              readonly attribute DOMString tone
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType">
                    <code>RTCDTMFToneChangeEventInit</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDTMFToneChangeEvent" data-dfn-for=
          "RTCDTMFToneChangeEvent" class="attributes">
            <dt><code>tone</code> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly</dt>
            <dd>
              <p>The <dfn><code>tone</code></dfn> attribute contains the
              character for the tone that has just begun playout (see
              <code><a>insertDTMF</a></code> ). If the value is the empty
              string, it indicates that the previous tone has completed
              playback.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">dictionary RTCDTMFToneChangeEventInit : EventInit {
             required DOMString tone;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDTMFToneChangeEventInit</a>
          Members</h2>
          <dl data-link-for="RTCDTMFToneChangeEventInit" data-dfn-for=
          "RTCDTMFToneChangeEventInit" class="dictionary-members">
            <dt><dfn><code>tone</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The <code>tone</code> attribute contains the
              character for the tone that has just begun playout (see
              <code><a>insertDTMF</a></code> ). If the value is the empty
              string, it indicates that the previous tone has completed
              playback.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>
  <section>
    <h2 id="sec.stats-model">Statistics Model</h2>
    <section>
      <h3>Introduction</h3>
      <p>The basic statistics model is that the browser maintains a set of
      statistics referenced by a <dfn id="stats-selector">selector</dfn>. The
      selector may, for example, be a <code>MediaStreamTrack</code>. For a
      track to be a valid selector, it MUST be a <code>MediaStreamTrack</code>
      that is sent or received by the <code><a>RTCPeerConnection</a></code>
      object on which the stats request was issued. The calling Web application
      provides the selector to the <code><a data-for=
      "RTCPeerConnection">getStats()</a></code> method and the browser emits
      (in the JavaScript) a set of statistics that it believes is relevant to
      the selector.</p>
      <div class="issue">
        Evaluate the need for other selectors than MediaStreamTrack.
      </div>
      <p>The statistics returned are designed in such a way that repeated
      queries can be linked by the <code><a>RTCStats</a></code> <a data-for=
      "RTCStats">id</a> dictionary member. Thus, a Web application can make
      measurements over a given time period by requesting measurements at the
      beginning and end of that period.</p>
    </section>
    <section>
      <h3>RTCPeerConnection Interface Extensions</h3>
      <p>The Statistics API extends the <code><a>RTCPeerConnection</a></code>
      interface as described below.</p>
      <div>
        <pre class="idl">partial interface RTCPeerConnection {
    Promise&lt;RTCStatsReport&gt; getStats (optional MediaStreamTrack? selector = null);
};</pre>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="methods">
            <dt><code>getStats</code></dt>
            <dd>
              <p>Gathers stats for the given <a>selector</a> and reports the
              result asynchronously.</p>
              <p>When the <dfn id=
              "widl-RTCPeerConnection-getStats-Promise-RTCStatsReport--MediaStreamTrack-selector">
              <code>getStats()</code></dfn> method is invoked, the user agent
              MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>selectorArg</var> be the methods first
                  argument.</p>
                </li>
                <li>
                  <p>If <var>selectorArg</var> is neither <code>null</code> nor
                  a valid <a>selector</a>, return a promise rejected with a
                  <code>TypeError</code>.</p>
                </li>
                <li>
                  <p>Let <var>p</var> be a new promise.</p>
                </li>
                <li>
                  <p>Run the following steps in parallel:</p>
                  <ol>
                    <li>
                      <p>Start gathering the stats indicated by
                      <var>selectorArg</var>. If <var>selectorArg</var> is
                      null, stats MUST be gathered for the whole
                      <code><a>RTCPeerConnection</a></code> object.</p>
                    </li>
                    <li>
                      <p>When the relevant stats have been gathered, resolve
                      <var>p</var> with a new
                      <code><a>RTCStatsReport</a></code> object, representing
                      the gathered stats.</p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>Return <var>p</var>.</p>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">selector</td>
                    <td class="prmType"><code>MediaStreamTrack =
                    null</code></td>
                    <td class="prmNullTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em>
                <code>Promise&lt;RTCStatsReport&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>RTCStatsCallback</h3>
      <div>
        <pre class="idl">
        callback RTCStatsCallback = void (RTCStatsReport report);</pre>
        <section>
          <h2>Callback <a class="idlType">RTCStatsCallback</a> Parameters</h2>
          <dl data-link-for="RTCStatsCallback" data-dfn-for="RTCStatsCallback"
          class="callback-members">
            <dt><code>report</code> of type <span class=
            "idlMemberType"><a>RTCStatsReport</a></span></dt>
            <dd>
              <p>A <code><a>RTCStatsReport</a></code> representing the gathered
              stats.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>RTCStatsReport Object</h3>
      <p>The <code><a data-for="RTCPeerConnection">getStats()</a></code> method
      delivers a successful result in the form of an
      <code><a>RTCStatsReport</a></code> object. An
      <code><a>RTCStatsReport</a></code> object is a map between strings that
      identify the inspected objects (<a data-for=
      "RTCStats"><code>id</code></a> attribute in <code>RTCStats</code>
      instances), and their corresponding <code><a>RTCStats</a></code>-derived
      dictionaries.</p>
      <p>An <code><a>RTCStatsReport</a></code> may be composed of several
      <code><a>RTCStats</a></code>-derived dictionaries, each reporting stats
      for one underlying object that the implementation thinks is relevant for
      the <a>selector</a>. One achieves the total for the <a>selector</a> by
      summing over all the stats of a certain type; for instance, if a
      <code>MediaStreamTrack</code> is carried by multiple SSRCs over the
      network, the <code><a>RTCStatsReport</a></code> may contain one
      <code>RTCStats</code>-derived dictionary per SSRC (which can be
      distinguished by the value of the "ssrc" stats attribute).</p>
      <div>
        <pre class="idl">interface RTCStatsReport {
    readonly maplike&lt;DOMString, object&gt;;
};</pre>
        <p>This interface has "entries", "forEach", "get", "has", "keys",
        "values", @@iterator methods and a "size" getter brought by
        <code>readonly maplike</code>.</p>
        <p>Use these to retrieve the various dictionaries descended from
        <code><a>RTCStats</a></code> that this stats report is composed of. The
        set of supported property names [[!WEBIDL-1]] is defined as the ids of
        all the <code><a>RTCStats</a></code>-derived dictionaries that have
        been generated for this stats report.</p>
      </div>
    </section>
    <section>
      <h3>RTCStats Dictionary</h3>
      <p>An <code><a>RTCStats</a></code> dictionary represents the stats
      gathered by inspecting a specific object relevant to a <a>selector</a>.
      The <code><a>RTCStats</a></code> dictionary is a base type that specifies
      as set of default attributes, such as <a data-for=
      "RTCStats">timestamp</a> and <a data-for="RTCStats">type</a>. Specific
      stats are added by extending the <code><a>RTCStats</a></code>
      dictionary.</p>
      <p>Note that while stats names are standardized, any given implementation
      may be using experimental values or values not yet known to the Web
      application. Thus, applications MUST be prepared to deal with unknown
      stats.</p>
      <div class="issue">
        Need to define an IANA registry for this and populate with pointers to
        existing things such as the RTCP statistics.
      </div>
      <p>Statistics need to be synchronized with each other in order to yield
      reasonable values in computation; for instance, if "bytesSent" and
      "packetsSent" are both reported, they both need to be reported over the
      same interval, so that "average packet size" can be computed as "bytes /
      packets" - if the intervals are different, this will yield errors. Thus
      implementations MUST return synchronized values for all stats in an
      <code><a>RTCStats</a></code>-derived dictionary.</p>
      <div>
        <pre class="idl">dictionary RTCStats {
             DOMHighResTimeStamp timestamp;
             RTCStatsType        type;
             DOMString           id;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCStats</a> Members</h2>
          <dl data-link-for="RTCStats" data-dfn-for="RTCStats" class=
          "dictionary-members">
            <dt><code>timestamp</code> of type <span class=
            "idlMemberType"><a>DOMHighResTimeStamp</a></span></dt>
            <dd>
              <p>The <dfn><code>timestamp</code></dfn>, of type
              <code>DOMHighResTimeStamp</code> [[!HIGHRES-TIME]], associated
              with this object. The time is relative to the UNIX epoch (Jan 1,
              1970, UTC).</p>
            </dd>
            <dt><code>type</code> of type <span class=
            "idlMemberType"><a>RTCStatsType</a></span></dt>
            <dd>
              <p>The type of this object.</p>
              <p>The <dfn><code>type</code></dfn> attribute MUST be initialized
              to the name of the most specific type this
              <code><a>RTCStats</a></code> dictionary represents.</p>
            </dd>
            <dt><code>id</code> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>A unique <dfn><code>id</code></dfn> that is associated with
              the object that was inspected to produce this
              <code><a>RTCStats</a></code> object. Two
              <code><a>RTCStats</a></code> objects, extracted from two
              different <code><a>RTCStatsReport</a></code> objects, MUST have
              the same id if they were produced by inspecting the same
              underlying object. User agents are free to pick any format for
              the id as long as it meets the requirements above.</p>
              <div class="issue">
                Consider naming id something that indicates that the id refers
                to the underlying object that was inspected to produce the
                stats, instead of being an id for the JavaScript object.
                Suggestions: statsObjectId, reporterId, srcId.
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">enum RTCStatsType {
    "inboundrtp",
    "outboundrtp"
};</pre>
        <table data-link-for="RTCStatsType" data-dfn-for="RTCStatsType" class=
        "simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code>inboundrtp</code></dfn></td>
              <td>Inbound RTP.</td>
            </tr>
            <tr>
              <td><dfn><code>outboundrtp</code></dfn></td>
              <td>Outbound RTP.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section>
      <h3>Derived Stats Dictionaries</h3>
      <div>
        <pre class="idl">dictionary RTCRTPStreamStats : RTCStats {
             unsigned long ssrc;
             DOMString     remoteId;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRTPStreamStats</a> Members</h2>
          <dl data-link-for="RTCRTPStreamStats" data-dfn-for=
          "RTCRTPStreamStats" class="dictionary-members">
            <dt><dfn><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
            <dt><dfn><code>remoteId</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The <code>remoteId</code> can be used to look up the
              corresponding <code><a>RTCStats</a></code> object that represents
              stats reported by the other peer.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
        dictionary RTCInboundRTPStreamStats : RTCRTPStreamStats {
             unsigned long packetsReceived;
             unsigned long bytesReceived;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCInboundRTPStreamStats</a>
          Members</h2>
          <dl data-link-for="RTCInboundRTPStreamStats" data-dfn-for=
          "RTCInboundRTPStreamStats" class="dictionary-members">
            <dt><dfn><code>packetsReceived</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
            <dt><dfn><code>bytesReceived</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
        dictionary RTCOutboundRTPStreamStats : RTCRTPStreamStats {
             unsigned long packetsSent;
             unsigned long bytesSent;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCOutboundRTPStreamStats</a>
          Members</h2>
          <dl data-link-for="RTCOutboundRTPStreamStats" data-dfn-for=
          "RTCOutboundRTPStreamStats" class="dictionary-members">
            <dt><dfn><code>packetsSent</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
            <dt><dfn><code>bytesSent</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>...</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>Example</h3>
      <p>Consider the case where the user is experiencing bad sound and the
      application wants to determine if the cause of it is packet loss. The
      following example code might be used:</p>
      <pre class="example highlight">var baselineReport, currentReport;
var selector = pc.getSenders()[0].track;

pc.getStats(selector).then(function (report) {
    baselineReport = report;
})
.then(function() {
    return new Promise(function(resolve) {
        setTimeout(resolve, aBit); // ... wait a bit
    });
})
.then(function() {
    return pc.getStats(selector);
})
.then(function (report) {
    currentReport = report;
    processStats();
})
.catch(function (error) {
  log(error.toString());
});

function processStats() {
    // compare the elements from the current report with the baseline
    currentReport.forEach (now =&gt; {
        if (now.type != "outboundrtp")
            return;

        // get the corresponding stats from the baseline report
        base = baselineReport.get(now.id);

        if (base) {
            remoteNow = currentReport.get(now.remoteId);
            remoteBase = baselineReport.get(base.remoteId);

            var packetsSent = now.packetsSent - base.packetsSent;
            var packetsReceived = remoteNow.packetsReceived - remoteBase.packetsReceived;

            // if fractionLost is &gt; 0.3, we have probably found the culprit
            var fractionLost = (packetsSent - packetsReceived) / packetsSent;
        }
    }
}
</pre>
    </section>
  </section>
  <section>
    <h2 id="sec.identity-proxy">Identity</h2>
    <section>
      <h3>Identity Provider Interaction</h3>
      <p>WebRTC offers and answers (and hence the channels established by
      <code><a>RTCPeerConnection</a></code> objects) can be authenticated by
      using a web-based Identity Provider (IdP). The idea is that the entity
      sending an offer or answer acts as the Authenticating Party (AP) and
      obtains an identity assertion from the IdP which it attaches to the
      session description. The consumer of the session description (i.e., the
      <code><a>RTCPeerConnection</a></code> on which
      <code>setRemoteDescription</code> is called) acts as the Relying Party
      (RP) and verifies the assertion.</p>
      <p>The interaction with the IdP is designed to decouple the browser from
      any particular identity provider; the browser need only know how to load
      the IdP's JavaScript, the location of which is determined by the IdP's
      identity, and the generic interface to generating and validating
      assertions. The IdP provides whatever logic is necessary to bridge the
      generic protocol to the IdP's specific requirements. Thus, a single
      browser can support any number of identity protocols, including being
      forward compatible with IdPs which did not exist at the time the browser
      was written.</p>
      <section>
        <h4 id="sec.identity-proxy-communications">Identity Provider
        Selection</h4>
        <p>An IdP is used to generate an identity assertion as follows:</p>
        <ol>
          <li>If the <code>setIdentityProvider()</code> method has been called,
          the IdP provided shall be used.</li>
          <li>If the <code>setIdentityProvider()</code> method has not been
          called, then the user agent MAY use an IdP configured into the
          browser.</li>
        </ol>
        <p>In order to verify assertions, the IdP domain name and protocol are
        taken from the <code>domain</code> and <code>protocol</code> fields of
        the identity assertion.</p>
      </section>
      <section>
        <h4 id="sec.create-identity-proxy">Instantiating an IdP Proxy</h4>
        <p>In order to communicate with the IdP, the user agent loads the IdP
        JavaScript from the IdP. The URI for the IdP script is a well-known URI
        formed from the <q>domain</q> and <q>protocol</q> fields, as specified
        in [[!RTCWEB-SECURITY-ARCH]].</p>
        <p>The IdP MAY generate an HTTP redirect to another "https" origin, the
        browser MUST treat a redirect to any other scheme as a fatal error.</p>
        <p>The user agent instantiates an isolated interpreted context, a
        JavaScript <a href=
        "http://people.mozilla.org/~jorendorff/es6-draft.html#sec-code-realms"><dfn>
        realm</dfn></a> that operates in the origin of the loaded JavaScript.
        Note that a redirect will change the origin of the loaded script.</p>
        <p>The <a>realm</a> is populated with a global that implements
        both the <code><a>RTCIdentityProviderGlobalScope</a></code> and
        <code>WorkerGlobalScope</code> [[!WEBWORKERS]] interfaces.</p>
        <p>The user agent provides an instance of
        <code><a>RTCIdentityProviderRegistrar</a></code> named
        <var>rtcIdentityProvider</var> in the global scope of the <a>realm</a>.
        This object is used by the IdP to interact with the user agent.</p>
        <div>
          <pre class="idl">[Global, Exposed=RTCIdentityProviderGlobalScope]
interface RTCIdentityProviderGlobalScope : WorkerGlobalScope {
    readonly        attribute RTCIdentityProviderRegistrar rtcIdentityProvider;
};</pre>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="RTCIdentityProviderGlobalScope" data-dfn-for=
            "RTCIdentityProviderGlobalScope" class="attributes">
              <dt><dfn><code>rtcIdentityProvider</code></dfn> of type
              <span class=
              "idlAttrType"><a>RTCIdentityProviderRegistrar</a></span>,
              readonly</dt>
              <dd>This object is used by the IdP to register an
              <code><a>RTCIdentityProvider</a></code> instance with the
              browser.</dd>
            </dl>
          </section>
        </div>
        <section>
          <h2 id="sec.implement-idp">Implementing an IdP Securely</h2>
          <p>An environment that mimics the identity provider realm can be
          provided by any script. However, only scripts running in the origin
          of the IdP are able to generate an identical environment. Other
          origins can load and run the IdP proxy code, but they will be unable
          to replicate data that is unique to the origin of the IdP.</p>
          <p>This means that it is critical that an IdP use data that is
          restricted to its own origin when generating identity assertions.
          Otherwise, another origin could load the IdP script and use it to
          impersonate users.</p>
          <p>The data that the IdP script uses could be stored on the client
          (for example, in <a href=
          "http://www.w3.org/TR/IndexedDB/">IndexedDB</a>) or loaded from
          servers. Data that is acquired from a server SHOULD require
          credentials and be protected from cross-origin access.</p>
          <p>There is no risk to the integrity of identity assertions if an IdP
          validates an identity assertion without using origin-private
          data.</p>
        </section>
      </section>
    </section>
    <section>
      <h2 id="sec.register-idp">Registering an IdP Proxy</h2>
      <p>An IdP proxy implements the <code><a>RTCIdentityProvider</a></code>
      methods, which are the means by which the user agent is able to request
      that an identity assertion be generated or validated.</p>
      <p>Once instantiated, the IdP script is executed. The IdP MUST call the
      <code>register()</code> function on the
      <code><a>RTCIdentityProviderRegistrar</a></code> instance during script
      execution. If an IdP is not registered during this script execution, the
      user agent cannot use the IdP proxy and MUST fail any future attempt to
      interact with the IdP.</p>
      <div>
        <pre class="idl">[Exposed=RTCIdentityProviderGlobalScope]
interface RTCIdentityProviderRegistrar {
    void register (RTCIdentityProvider idp);
};</pre>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCIdentityProviderRegistrar" data-dfn-for=
          "RTCIdentityProviderRegistrar" class="methods">
            <dt><dfn><code>register</code></dfn></dt>
            <dd>
              <p>This method is invoked by the IdP when its script is first
              executed. This registers <code><a>RTCIdentityProvider</a></code>
              methods with the user agent.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">idp</td>
                    <td class="prmType"><code>RTCIdentityProvider</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <section>
        <h2>Interface Exposed by Identity Providers</h2>
        <p>The callback functions in <code>RTCIdentityProvider</code> are
        exposed by identity providers and is called by
        <code>RTCPeerConnection</code> to acquire or validate identity
        assertions.</p>
        <div>
          <pre class="idl">dictionary RTCIdentityProvider {
    required GenerateAssertionCallback generateAssertion;
    required ValidateAssertionCallback validateAssertion;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIdentityProvider</a>
            Members</h2>
            <dl data-link-for="RTCIdentityProvider" data-dfn-for=
            "RTCIdentityProvider" class="dictionary-members">
              <dt><dfn><code>generateAssertion</code></dfn> of type
              <span class="idlMemberType"><a>GenerateAssertionCallback</a></span>,
              required</dt>
              <dd>
                <p>A user agent invokes this method on the IdP to request the
                generation of an identity assertion.</p>
                <p>The IdP provides a promise that resolves to an
                <code><a>RTCIdentityAssertionResult</a></code> to successfully
                generate an identity assertion. Any other value, or a rejected
                promise, is treated as an error.</p>
              </dd>
              <dt><dfn><code>validateAssertion</code></dfn> of type
              <span class="idlMemberType"><a>ValidateAssertionCallback</a></span>,
              required</dt>
              <dd>
                <p>A user agent invokes this method on the IdP to request the
                validation of an identity assertion.</p>
                <p>The IdP returns a Promise that resolves to an
                <code><a>RTCIdentityValidationResult</a></code> to successfully
                validate an identity assertion and to provide the actual
                identity. Any other value, or a rejected promise, is treated as
                an error.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">
          callback GenerateAssertionCallback = Promise&lt;RTCIdentityAssertionResult&gt; (DOMString contents, DOMString origin, optional DOMString usernameHint);</pre>
          <section>
            <h2>Callback <a class="idlType">GenerateAssertionCallback</a>
            Parameters</h2>
            <dl data-link-for="GenerateAssertionCallback" data-dfn-for=
            "GenerateAssertionCallback" class="callback-members">
              <dt><code>contents</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>The <var>contents</var> parameter includes the information
              that the user agent wants covered by the identity assertion. A
              successful validation of the provided assertion MUST produce this
              string.</dd>
              <dt><code>origin</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>
                The <var>origin</var> parameter identifies the origin of the
                <code><a>RTCPeerConnection</a></code> that triggered this
                request. An IdP can use this information as input to policy
                decisions about use. This value is generated by the <a>user
                agent</a> based on the origin of the document that created the
                <code>RTCPeerConnection</code> and therefore can be trusted to
                be correct.
              </dd>
              <dt><code>usernameHint</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>The IdP selects the identity to assert. The optional
              <var>usernameHint</var> parameter is the same value that was
              passed to <code>setIdentityProvider</code>.</dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">
          callback ValidateAssertionCallback = Promise&lt;RTCIdentityValidationResult&gt; (DOMString assertion, DOMString origin);</pre>
          <section>
            <h2>Callback <a class="idlType">ValidateAssertionCallback</a>
            Parameters</h2>
            <dl data-link-for="ValidateAssertionCallback" data-dfn-for=
            "ValidateAssertionCallback" class="callback-members">
              <dt><code>assertion</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>The <var>assertion</var> parameter includes the assertion
              that was recovered from an <code>a=identity</code> in the session
              description; that is, the value that was part of the
              <code><a>RTCIdentityAssertionResult</a></code> provided by the
              IdP that generated the assertion.</dd>
              <dt><code>origin</code> of type <span class=
              "idlMemberType"><a>DOMString</a></span></dt>
              <dd>The <var>origin</var> parameter identifies the origin of the
              <code><a>RTCPeerConnection</a></code> that triggered this
              request. An IdP can use this information as input to policy
              decisions about use.</dd>
            </dl>
          </section>
        </div>
      </section>
      <section>
        <h2>Identity Assertion and Validation Results</h2>
        <div>
          <pre class="idl">dictionary RTCIdentityAssertionResult {
    required RTCIdentityProviderDetails idp;
    required DOMString                  assertion;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIdentityAssertionResult</a>
            Members</h2>
            <dl data-link-for="RTCIdentityAssertionResult" data-dfn-for=
            "RTCIdentityAssertionResult" class="dictionary-members">
              <dt><dfn><code>idp</code></dfn> of type <span class=
              "idlMemberType"><a>RTCIdentityProviderDetails</a></span>,
              required</dt>
              <dd>
                <p>An IdP provides these details to identify the IdP that
                validates the identity assertion. This struct contains the same
                information that is provided to
                <code>setIdentityProvider</code>.</p>
              </dd>
              <dt><dfn><code>assertion</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, required</dt>
              <dd>
                <p>An identity assertion. This is an opaque string that MUST
                contain all information necessary to assert identity. This
                value is consumed by the validating IdP.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCIdentityProviderDetails {
    required DOMString domain;
             DOMString protocol = "default";
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIdentityProviderDetails</a>
            Members</h2>
            <dl data-link-for="RTCIdentityProviderDetails" data-dfn-for=
            "RTCIdentityProviderDetails" class="dictionary-members">
              <dt><dfn><code>domain</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, required</dt>
              <dd>
                <p>The domain name of the IdP that validated the associated
                identity assertion.</p>
              </dd>
              <dt><dfn><code>protocol</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, defaulting to
              <code>"default"</code></dt>
              <dd>
                <p>The protocol parameter used for the IdP.</p>
              </dd>
            </dl>
          </section>
        </div>
        <div>
          <pre class="idl">dictionary RTCIdentityValidationResult {
    required DOMString identity;
    required DOMString contents;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCIdentityValidationResult</a>
            Members</h2>
            <dl data-link-for="RTCIdentityValidationResult" data-dfn-for=
            "RTCIdentityValidationResult" class="dictionary-members">
              <dt><dfn><code>identity</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, required</dt>
              <dd>
                <p>The validated identity of the peer.</p>
              </dd>
              <dt><dfn><code>contents</code></dfn> of type <span class=
              "idlMemberType"><a>DOMString</a></span>, required</dt>
              <dd>
                <p>The payload of the identity assertion. An IdP that validates
                an identity assertion MUST return the same string that was
                provided to the original IdP that generated the assertion.</p>
                <p>The user agent uses the <var>contents</var> string to
                determine if the identity assertion matches the session
                description.</p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h3 id="sec.identity-proxy-assertion-request">Requesting Identity
      Assertions</h3>
      <p>The identity assertion request process is triggered by a call to
      <code>createOffer</code>, <code>createAnswer</code>, or
      <code>getIdentityAssertion</code>. When these calls are invoked and an
      identity provider has been set, the following steps are executed:</p>
      <ol>
        <li>
          <p>The <code>RTCPeerConnection</code> instantiates an IdP as
          described in <a href="#sec.identity-proxy-communications">Identity
          Provider Selection</a> and <a href="#sec.register-idp">Registering an
          IdP Proxy</a>. If the IdP cannot be loaded, instantiated, or the IdP
          proxy is not registered, this process fails.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> invokes the <code><a data-for=
          "RTCIdentityProvider">generateAssertion</a></code> method on the
          <code><a>RTCIdentityProvider</a></code> methods registered by the
          IdP.</p>
          <p>The <code>RTCPeerConnection</code> generates the
          <var>contents</var> parameter to this method as described in
          [[!RTCWEB-SECURITY-ARCH]]. The value of <var>contents</var> includes
          the fingerprint of the certificate that was selected or generated
          during the construction of the <code>RTCPeerConnection</code>. The
          <var>origin</var> parameter contains the origin of the script that
          calls the <code>RTCPeerConnection</code> method that triggers this
          behavior. The <var>usernameHint</var> value is the same value that is
          provided to <code>setIdentityProvider</code>, if any such value was
          provided.</p>
        </li>
        <li>
          <p>The IdP proxy returns a Promise to the
          <code>RTCPeerConnection</code>.  The IdP proxy is expected to
          generate the identity assertion asynchronously.</p>
          <p>If the user has been authenticated by the IdP, and the IdP is
          able to generate an identity assertion, the IdP resolves the
          promise with an identity assertion in the form of an
          <code><a>RTCIdentityAssertionResult</a></code>.</p>
          <p>This step depends entirely on the IdP. The methods by which an IdP
          authenticates users or generates assertions is not specified, though
          they could involve interacting with the IdP server or other
          servers.</p>
        </li>
        <li>
          <p>If the IdP proxy produces an error or returns a promise that does
          not resolve to a valid
          <code><a>RTCIdentityValidationResult</a></code> (see <a href=
          "#sec.idp-error-handling"></a>), then identity validation fails.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> MAY store the identity
          assertion for use with future offers or answers. If a fresh identity
          assertion is needed for any reason, applications can create a new
          <code>RTCPeerConnection</code>.</p>
        </li>
        <li>
          <p>If the identity request was triggered by a
          <code>createOffer()</code> or <code>createAnswer()</code>, then the
          assertion is converted to a JSON string, base64-encoded and inserted
          into an <code>a=identity</code> attribute in the session
          description.</p>
        </li>
      </ol>
      <p>If assertion generation fails, then the promise for the corresponding
      function call is rejected with a <code>DOMException</code> that has the
      name <code>OperationError</code>.</p>
      <section>
        <h4 id="sec.idp-loginneeded">User Login Procedure</h4>
        <p>An IdP MAY reject an attempt to generate an identity assertion if it
        is unable to verify that a user is authenticated. This might be due to
        the IdP not having the necessary authentication information available
        to it (such as cookies).</p>
        <p>Rejecting the promise returned by <code><a data-for=
        "RTCIdentityProvider">generateAssertion</a></code> will cause the error
        to propagate to the application. Login errors are indicated by
        rejecting the promise with an object that has a <code>name</code>
        attribute set to "IdpLoginError".</p>
        <p>If the rejection object also contains a <code>loginUrl</code>
        attribute, this value will be passed to the application in the
        <code>idpLoginUrl</code> attribute. This URL might link to page where a
        user can enter their (IdP) username and password, or otherwise provide
        any information the IdP needs to authorize a assertion request.</p>
        <p>An application can load the login URL in an IFRAME or popup window;
        the resulting page then SHOULD provide the user with an opportunity to
        enter any information necessary to complete the authorization
        process.</p>
        <p>Once the authorization process is complete, the page loaded in the
        IFRAME or popup sends a message using <var>postMessage</var>
        [[!webmessaging]] to the page that loaded it (through the <var><a href=
        "http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-opener">
        window.opener</a></var> attribute for popups, or through <var><a href=
        "http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-parent">
        window.parent</a></var> for pages loaded in an IFRAME). The message
        MUST consist of the <var>DOMString</var> "LOGINDONE". This message
        informs the application that another attempt at generating an identity
        assertion is likely to be successful.</p>
      </section>
    </section>
    <section>
      <h3 id="sec.identity-verify-assertion">Verifying Identity Assertions</h3>
      <p>Identity assertion validation happens when <code><a data-for=
      "RTCPeerConnection">setRemoteDescription</a></code> is invoked on
      <code><a>RTCPeerConnection</a></code>. The process runs asynchronously,
      meaning that validation of an identity assertion might not block the
      completion of <code>setRemoteDescription</code>.</p>
      <p>The identity assertion request process involves the following
      asynchronous steps:</p>
      <ol>
        <li>
          <p>The <code>RTCPeerConnection</code> awaits any prior identity
          validation. Only one identity validation can run at a time for an
          <code>RTCPeerConnection</code>. This can happen because the
          resolution of <code>setRemoteDescription</code> is not blocked by
          identity validation unless there is a <a>target peer
          identity</a>.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> loads the identity assertion
          from the session description and decodes the base64 value, then
          parses the resulting JSON. The <var>idp</var> parameter of the
          resulting dictionary contains a <var>domain</var> and an optional
          <var>protocol</var> value that identifies the IdP, as described in
          [[!RTCWEB-SECURITY-ARCH]].</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> instantiates the identified IdP
          as described in <a href="#sec.identity-proxy-communications"></a> and
          <a href="#sec.register-idp"></a>. If the IdP cannot be loaded,
          instantiated or the IdP proxy is not registered, this process
          fails.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> invokes the <code><a data-for=
          "RTCIdentityProvider">validateAssertion</a></code> method registered
          by the IdP.</p>
          <p>The <var>assertion</var> parameter is taken from the decoded
          identity assertion. The <var>origin</var> parameter contains the
          origin of the script that calls the <code>RTCPeerConnection</code>
          method that triggers this behavior.</p>
        </li>
        <li>
          <p>The IdP proxy returns a promise and performs the validation
          process asynchronously.</p>
          <p>The IdP proxy verifies the identity assertion using whatever means
          necessary. Depending on the authentication protocol this could
          involve interacting with the IdP server.</p>
        </li>
        <li>
          <p>If the IdP proxy produces an error or returns a promise that does
          not resolve to a valid
          <code><a>RTCIdentityValidationResult</a></code> (see <a href=
          "#sec.idp-error-handling"></a>), then identity validation fails.</p>
        </li>
        <li>
          <p>Once the assertion is successfully verified, the IdP proxy
          resolves the promise with an
          <code><a>RTCIdentityValidationResult</a></code> containing the
          validated identity and the original contents that are the payload of
          the assertion.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> decodes the <code><a data-for=
          "RTCIdentityValidationResult">contents</a></code> and validates that
          it contains a fingerprint value for every <code>a=fingerprint</code>
          attribute in the session description. This ensures that the
          certificate used by the remote peer for communications is covered by
          the identity assertion.</p>
          <p class="note">A <a>user agent</a> is required to fail to
          communicate with peers that offer a certificate that doesn't match an
          <code>a=fingerprint</code> line in the negotiated session
          description.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> validates that the domain
          portion of the identity matches the domain of the IdP as described in
          [[!RTCWEB-SECURITY-ARCH]]. If this check fails then the identity
          validation fails.</p>
        </li>
        <li>
          <p>The <code>RTCPeerConnection</code> resolves the <code><a data-for=
          "RTCPeerConnection">peerIdentity</a></code> attribute with a new
          instance of <code>RTCIdentityAssertion</code> that includes the IdP
          domain and peer identity.</p>
        </li>
        <li>
          <p>The <a>user agent</a> MAY display identity information to a user
          in its UI. Any user identity information that is displayed in this
          fashion MUST use a mechanism that cannot be spoofed by content.</p>
        </li>
      </ol>
      <p>If identity validation fails, the <code><a data-for=
      "RTCPeerConnection">peerIdentity</a></code> promise is rejected with a
      <code>DOMException</code> that has a name of
      <code>OperationError</code>.</p>
      <p>If identity validation fails and there is a <a>target peer
      identity</a> for the <code>RTCPeerConnection</code>, the promise returned
      by <code>setRemoteDescription</code> MUST be rejected with the same
      <code>DOMException</code>.</p>
      <p>If identity validation fails and there is no a <a>target peer
      identity</a>, the value of the <code><a data-for=
      "RTCPeerConnection">peerIdentity</a></code> MUST be set to a new,
      unresolved promise instance. This permits the use of renegotiation (or a
      subsequent answer, if the session description was a provisional answer)
      to resolve or reject the identity.</p>
    </section>
    <section>
      <h2 id="sec.idp-error-handling">IdP Error Handling</h2>
      <p>Errors in IdP processing will - in most cases - result in the failure
      of the procedure that invoked the IdP proxy. This will result in the
      rejection of the promise returned by <code><a data-for=
      "RTCPeerConnection">getIdentityAssertion</a></code>, <code><a data-for=
      "RTCPeerConnection">createOffer</a></code>, or <code><a data-for=
      "RTCPeerConnection">createAnswer</a></code>. An IdP proxy error causes a
      <code><a data-for="RTCPeerConnection">setRemoteDescription</a></code>
      promise to be rejected if there is a <a>target peer identity</a>; IdP
      errors in calls to <code><a data-for=
      "RTCPeerConnection">setRemoteDescription</a></code> where there is no
      <a>target peer identity</a> cause the <code><a data-for=
      "RTCPeerConnection">peerIdentity</a></code> promise to be rejected
      instead.</p>
      <p>If an error occurs these promises are rejected with a
      <code>DOMException</code> that has a name of <code>OperationError</code>
      if an error occurs in interacting with the IdP proxy. The following
      scenarios result in errors:</p>
      <ul>
        <li>
          <p>A <code>RTCPeerConnection</code> might be configured with an
          identity provider, but that identity provider could register a
          <code>RTCIdentityProvider</code> with invalid methods. Any procedure
          that attempts to invoke such an identity provider fails.</p>
        </li>
        <li>
          <p>An apparently valid identity provider might fail in several ways.
          If an identity provider throws an exception or returns a promise that
          is ultimately rejected, then the procedure that depends on the IdP
          MUST also fail.</p>
        </li>
        <li>
          <p>The <a>user agent</a> SHOULD limit the time that allows for an IdP
          to run. This includes both the loading of the <a href=
          "#sec.identity-proxy-communications">IdP proxy</a> and the identity
          assertion generation or validation. Failure to do so potentially
          causes the corresponding operation to take an indefinite amount of
          time. This timer can be cancelled when the IdP proxy produces a
          response. Expiration of this timer is treated like any other type of
          IdP failure.</p>
        </li>
        <li>
          <p>Even when the IdP proxy produces a positive result, the procedure
          that uses this information might still fail. Additional validation of
          a <a>RTCIdentityValidationResult</a> value is still necessary. The
          procedure for <a href="#sec.identity-verify-assertion">validation of
          identity assertions</a> describes additional steps that are required
          to successfully validate the output of the IdP proxy.</p>
        </li>
      </ul>
    </section>
    <section>
      <h3>RTCPeerConnection Interface Extensions</h3>
      <p>The Identity API extends the <code><a>RTCPeerConnection</a></code>
      interface as described below.</p>
      <div>
        <pre class="idl">partial interface RTCPeerConnection {
    void               setIdentityProvider (DOMString provider, optional DOMString protocol, optional DOMString usernameHint);
    Promise&lt;DOMString&gt; getIdentityAssertion ();
    readonly        attribute Promise&lt;RTCIdentityAssertion&gt; peerIdentity;
    readonly        attribute DOMString?                    idpLoginUrl;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="attributes">
            <dt><dfn><code>peerIdentity</code></dfn> of type <span class=
            "idlAttrType">Promise&lt;<a>RTCIdentityAssertion</a>&gt;</span>,
            readonly</dt>
            <dd>
              <p>A promise that resolves with the identity of the peer if the
              identity is successfully validated.</p>
              <p>This promise is rejected if an identity assertion is present
              in a remote session description and validation of that assertion
              fails for any reason. If the promise is rejected, a new
              unresolved value is created, unless there a <a>target peer
              identity</a> has been established. If this promise successfully
              resolves, the value will not change.</p>
            </dd>
            <dt><dfn><code>idpLoginUrl</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly , nullable</dt>
            <dd>
              <p>The URL that an application can navigate to so that the user
              can login to the IdP, as described in <a href=
              "#sec.idp-loginneeded"></a>.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCPeerConnection" data-dfn-for=
          "RTCPeerConnection" class="methods">
            <dt><code>setIdentityProvider</code></dt>
            <dd>
              <p>Sets the identity provider to be used for a given
              <code>RTCPeerConnection</code> object. Applications need not make
              this call; if the browser is already configured for an IdP, then
              that configured IdP might be used to get an assertion.</p>
              <p>When the <dfn><code>setIdentityProvider</code></dfn> method is
              invoked, the user agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>If the <code><a>RTCPeerConnection</a></code> object's
                  [[<a>isClosed</a>]] slot is <code>true</code>, throw an
                  <code>InvalidStateError</code> exception and abort these
                  steps.</p>
                </li>
                <li>
                  <p>Set the current identity provider values to the triplet
                  (<code>provider</code>, <code>protocol</code>,
                  <code>usernameHint</code>).</p>
                </li>
                <li>
                  <p>If any identity provider value has changed, discard any
                  stored identity assertion.</p>
                </li>
              </ol>
              <p>Identity provider information is not used until an identity
              assertion is required, either in response to a call to
              <code>getIdentityAssertion</code>, or a session description is
              requested with a call to either <code>createOffer</code> or
              <code>createAnswer</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">provider</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">protocol</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">usernameHint</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>getIdentityAssertion</code></dfn></dt>
            <dd>
              <p>Initiates the process of obtaining an identity assertion.
              Applications need not make this call. It is merely intended to
              allow them to start the process of obtaining identity assertions
              before a call is initiated. If an identity is needed, either
              because the browser has been configured with a default identity
              provider or because the <code>setIdentityProvider</code> method
              was called, then an identity will be automatically requested when
              an offer or answer is created.</p>
              <p>When <code>getIdentityAssertion</code> is invoked, queue a
              task to run the following steps:</p>
              <ol>
                <li>
                  <p>If the <code><a>RTCPeerConnection</a></code> object's
                  [[<a>isClosed</a>]] slot is <code>true</code>, throw an
                  <code>InvalidStateError</code> exception and abort these
                  steps.</p>
                </li>
                <li>
                  <p><a href="#sec.identity-proxy-assertion-request">Request an
                  identity assertion</a> from the IdP.</p>
                </li>
                <li>
                  <p>Resolve the promise with the base64 and JSON encoded
                  assertion.</p>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>Promise&lt;DOMString&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">[Constructor(DOMString idp, DOMString name)]
interface RTCIdentityAssertion {
                    attribute DOMString idp;
                    attribute DOMString name;
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIdentityAssertion" data-dfn-for=
          "RTCIdentityAssertion" class="attributes">
            <dt><dfn><code>idp</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span></dt>
            <dd>
              <p>The domain name of the identity provider that validated this
              identity.</p>
            </dd>
            <dt><dfn><code>name</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span></dt>
            <dd>
              <p>An RFC5322-conformant [[RFC5322]] representation of the
              verified peer identity. This identity will have been verified via
              the procedures described in [[!RTCWEB-SECURITY-ARCH]].</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3>Examples</h3>
      <p>The identity system is designed so that applications need not take any
      special action in order for users to generate and verify identity
      assertions; if a user has configured an IdP into their browser, then the
      browser will automatically request/generate assertions and the other side
      will automatically verify them and display the results. However,
      applications may wish to exercise tighter control over the identity
      system as shown by the following examples.</p>
      <div>
        <p>This example shows how to configure the identity provider and
        protocol.</p>
        <pre class="example highlight">
        pc.setIdentityProvider("example.com", "default", "alice@example.com");
</pre>
      </div>
      <div>
        <p>This example shows how to consume identity assertions inside a Web
        application.</p>
        <pre class="example highlight">  pc.peerIdentity.then(identity =&gt;
    console.log("IdP= " + identity.idp + " identity=" + identity.name));
</pre>
      </div>
    </section>
  </section>
  <section>
    <h2>Media Stream API Extensions for Network Use</h2>
    <section>
      <h3>Introduction</h3>
      <p>The <code>MediaStreamTrack</code> interface, as defined in the
      [[!GETUSERMEDIA]] specification, typically represents a stream of data of
      audio or video. One or more <code>MediaStreamTrack</code>s can be
      collected in a <code>MediaStream</code> (strictly speaking, a
      <code>MediaStream</code> as defined in [[!GETUSERMEDIA]] may contain zero
      or more <code>MediaStreamTrack</code> objects).</p>
      <p>A <code>MediaStreamTrack</code> may be extended to represent a media
      flow that either comes from or is sent to a remote peer (and not just the
      local camera, for instance). The extensions required to enable this
      capability on the <code>MediaStreamTrack</code> object will be described
      in this section. How the media is transmitted to the peer is described in
      [[!RTCWEB-RTP]], [[!RTCWEB-AUDIO]], and [[!RTCWEB-TRANSPORT]].</p>
      <p>A <code>MediaStreamTrack</code> sent to another peer will appear as
      one and only one <code>MediaStreamTrack</code> to the recipient. A peer
      is defined as a user agent that supports this specification. In addition,
      the sending side application can indicate what <code>MediaStream</code>
      object(s) the <code>MediaStreamTrack</code> is member of. The
      corresponding <code>MediaStream</code> object(s) on the receiver side
      will be created (if not already present) and populated accordingly.</p>
      <p>As also described earlier in this document, the objects
      <code>RTCRtpSender</code> and <code>RTCRtpReceiver</code> can be used by
      the application to get more fine grained control over the transmission
      and reception of <code>MediaStreamTrack</code>s.</p>
      <p>Channels are the smallest unit considered in the
      <code>MediaStream</code> specification. Channels are intended to be
      encoded together for transmission as, for instance, an RTP payload type.
      All of the channels that a codec needs to encode jointly MUST be in the
      same <code>MediaStreamTrack</code> and the codecs SHOULD be able to
      encode, or discard, all the channels in the track.</p>
      <p>The concepts of an input and output to a given
      <code>MediaStreamTrack</code> apply in the case of
      <code>MediaStreamTrack</code> objects transmitted over the network as
      well. A <code><a>MediaStreamTrack</a></code> created by an
      <code><a>RTCPeerConnection</a></code> object (as described previously in
      this document) will take as input the data received from a remote peer.
      Similarly, a <code>MediaStreamTrack</code> from a local source, for
      instance a camera via [[!GETUSERMEDIA]], will have an output that
      represents what is transmitted to a remote peer if the object is used
      with an <code><a>RTCPeerConnection</a></code> object.</p>
      <p>The concept of duplicating <code>MediaStream</code> and
      <code>MediaStreamTrack</code> objects as described in [[!GETUSERMEDIA]]
      is also applicable here. This feature can be used, for instance, in a
      video-conferencing scenario to display the local video from the user's
      camera and microphone in a local monitor, while only transmitting the
      audio to the remote peer (e.g. in response to the user using a "video
      mute" feature). Combining different <code>MediaStreamTrack</code> objects
      into new <code>MediaStream</code> objects is useful in certain
      situations.</p>
      <p class="note">In this document, we only specify aspects of the
      following objects that are relevant when used along with an
      <code><a>RTCPeerConnection</a></code>. Please refer to the original
      definitions of the objects in the [[!GETUSERMEDIA]] document for general
      information on using <code>MediaStream</code> and
      <code>MediaStreamTrack</code>.</p>
    </section>
    <section>
      <h3>MediaStream</h3>
      <section>
        <h4>id</h4>
        <p>The <code><a href=
        "https://w3c.github.io/mediacapture-main/#dom-mediastream-id">id</a></code>
        attribute specified in <code>MediaStream</code> returns an id that is
        unique to this stream, so that streams can be recognized at the remote
        end of the <code><a>RTCPeerConnection</a></code> API.</p>
        <p>When a <code><a>MediaStream</a></code> is created to represent a
        stream obtained from a remote peer, the <code><a href=
        "https://w3c.github.io/mediacapture-main/#dom-mediastream-id">id</a></code>
        attribute is initialized from information provided by the remote
        source.</p>
        <p class="note">The id of a <code><a>MediaStream</a></code> object is
        unique to the source of the stream, but that does not mean it is not
        possible to end up with duplicates. For example, the tracks of a
        locally generated stream could be sent from one user agent to a remote
        peer using <code><a>RTCPeerConnection</a></code> and then sent back to
        the original user agent in the same manner, in which case the original
        user agent will have multiple streams with the same id (the
        locally-generated one and the one received from the remote peer).</p>
      </section>
    </section>
    <section>
      <h3>MediaStreamTrack</h3>
      <p>A <code>MediaStreamTrack</code> object's reference to its
      <code>MediaStream</code> in the non-local media source case (an RTP
      source, as is the case for <code>MediaStreamTrack</code>s received over
      an <code><a>RTCPeerConnection</a></code> ) is always strong.</p>
      <p>When an <code><a>RTCPeerConnection</a></code> receives data on an RTP
      source for the first time, it MUST <a>update the muted state</a> of the
      corresponding <code><a>MediaStreamTrack</a></code> with the value
      <code>false</code>.</p>
      <p>When an <code><a>RTCPeerConnection</a></code>'s RTP source is
      temporarily unable to receive media due to a loss of connection or if a
      mute signal has been received, it MUST <a>update the muted state</a> of
      the corresponding <code><a>MediaStreamTrack</a></code> with the value
      <code>true</code>. When media data is available again, the <a data-lt=
      "update the muted state">muted state MUST be updated</a> with the value
      <code>false</code>.</p>
      <p class="issue">The mute signal mentioned in the previous paragraph is
      yet to be defined.</p>
      <p>The procedure <dfn data-lt="update the muted state" id=
      "update-track-muted">update a track's muted state</dfn> is specified in
      [[!GETUSERMEDIA]].</p>
      <p>When a track comes from a remote peer and the remote peer has
      permanently stopped sending data the <code>ended</code> event MUST be
      fired on the track, as specified in [[!GETUSERMEDIA]].</p>
      <p class="issue">How do you know when it has stopped? This seems like an
      SDP question, not a media-level question. (Suggestion: when the track is
      ended, either through port 0, or removing the a=msid attrib)</p>
      <p>When a <a>remote source</a> is notified that a
      <code><a>MediaStreamTrack</a></code>, using the source, has
      <code>ended</code> [[!GETUSERMEDIA]] the User Agent MAY choose to free
      resources allocated for the incoming stream, for instance turn off the
      decoder.</p>
      <section>
        <h4>MediaTrackSupportedConstraints, MediaTrackCapabilities,
        MediaTrackConstraints and MediaTrackSettings</h4>
        <p>The basics of <code>MediaTrackSupportedConstraints</code>,
        <code>MediaTrackCapabilites</code>,
        <code>MediaTrackConstraints</code> and
        <code>MediaTrackSettings</code> is outlined in
        [[!GETUSERMEDIA]]. However, the <code>MediaTrackSettings</code>
        for a <code>MediaStreamTrack</code> sourced by a
        <code><a>RTCPeerConnection</a></code> will only be populated to the
        extent that data is supplied by means of the remote
        <code><a>RTCSessionDescription</a></code> applied via
        <code>setRemoteDescription</code> and the actual RTP data. This means
        that certain settings, such as <code>facingMode</code>,
        <code>echoCancellation</code> , <code>latency</code>,
        <code>deviceId</code> and <code>groupId</code>, will
        always return null.</p>
      </section>
    </section>
    <section>
      <h3>Isolated Media Streams</h3>
      <p>A MediaStream acquired using <code>getUserMedia()</code> is, by
      default, accessible to an application. This means that the application is
      able to access the contents of tracks, modify their content, and send
      that media to any peer it chooses.</p>
      <p>WebRTC supports calling scenarios where media is sent to a
      specifically identified peer, without the contents of media streams being
      accessible to applications. This is enabled by use of the
      <code>peerIdentity</code> parameter to <code>getUserMedia()</code>.</p>
      <p>An application willingly relinquishes access to media by including a
      <code>peerIdentity</code> parameter in the
      <code>MediaStreamConstraints</code>. This attribute is set to a
      <code>DOMString</code> containing the identity of a specific peer.</p>
      <p>The <code>MediaStreamConstraints</code> dictionary is expanded to
      include the <code>peerIdentity</code> parameter.</p>
      <div>
        <pre class="idl">partial dictionary MediaStreamConstraints {
             DOMString peerIdentity;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">MediaStreamConstraints</a>
          Members</h2>
          <dl data-link-for="MediaStreamConstraints" data-dfn-for=
          "MediaStreamConstraints" class="dictionary-members">
            <dt><dfn><code>peerIdentity</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>If set, <code>peerIdentity</code> isolates media from the
              application. Media can only be sent to the identified peer.</p>
            </dd>
          </dl>
        </section>
      </div>
      <p>A user that is prompted to provide consent for access to a camera or
      microphone can be shown the value of the <code>peerIdentity</code>
      parameter, so that they can be informed that the consent is more narrowly
      restricted.</p>
      <p>When the <code><dfn>peerIdentity</dfn></code> option is supplied to
      <code>getUserMedia()</code>, all of the <code>MediaStreamTrack</code>s in
      the resulting <code>MediaStream</code> are isolated so that content is
      not accessible to any application. Isolated
      <code>MediaStreamTrack</code>s can be used for two purposes:</p>
      <ul>
        <li>
          <p>Displayed in an appropriate media tag (e.g., a video or audio
          element). The browser MUST ensure that content is inaccessible to the
          application by ensuring that the resulting content is given the same
          protections as content that is <a href=
          "http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-cross-origin">
          CORS cross-origin</a>, as described in the relevant <a href=
          "http://www.w3.org/html/wg/drafts/html/master/semantics.html#security-and-privacy-considerations">
          Security and privacy considerations section</a> of [[HTML5]].</p>
        </li>
        <li>
          <p>Used as the argument to <a data-for=
          "RTCPeerConnection">addTrack</a> on an
          <code><a>RTCPeerConnection</a></code> instance, subject to the
          restrictions in <a href="#isolated-pc">isolated streams and
          RTCPeerConnection</a>.</p>
        </li>
      </ul>
      <p>A <code>MediaStreamTrack</code> that is added to another
      <code>MediaStream</code> remains isolated. When an isolated
      <code>MediaStreamTrack</code> is added to a <code>MediaStream</code> with
      a different peerIdentity, the <code>MediaStream</code> gets a combination
      of isolation restrictions. A <code>MediaStream</code> containing
      <code>MediaStreamTrack</code> instances with mixed isolation properties
      can be displayed, but cannot be sent using
      <code><a>RTCPeerConnection</a></code>.</p>
      <p>Any <code>peerIdentity</code> property MUST be retained on cloned
      copies of <code>MediaStreamTrack</code>s.</p>
      <!-- Any stream or track that might be derived from an isolated stream,
           such as
           through <a href="https://www.w3.org/TR/streamproc/#media-element-extensions">captureStreamUntilEnded
           or captureStream</a>, MUST also retain any isolation protections.
        -->
      <section id="isolated-track">
        <h4>Extended MediaStreamTrack Properties</h4>
        <p><code>MediaStreamTrack</code> is expanded to include an
        <var>isolated</var> attribute and a corresponding event. This allows an
        application to quickly and easily determine whether a track is
        accessible.</p>
        <div>
          <pre class="idl">partial interface MediaStreamTrack {
    readonly        attribute boolean      isolated;
                    attribute EventHandler onisolationchange;
};</pre>
          <section>
            <h2>Attributes</h2>
            <dl data-link-for="MediaStreamTrack" data-dfn-for=
            "MediaStreamTrack" class="attributes">
              <dt><dfn><code>isolated</code></dfn> of type <span class=
              "idlAttrType"><a>boolean</a></span>, readonly</dt>
              <dd>
                <p>A <code>MediaStreamTrack</code> is isolated (and the
                corresponding <var>isolated</var> attribute set to
                <var>true</var>) when content is inaccessible to the owning
                document. This occurs as a result of setting the
                <var>peerIdentity</var> option. A track is also isolated if it
                comes from a cross origin source.</p>
              </dd>
              <dt><dfn><code>onisolationchange</code></dfn> of type
              <span class="idlAttrType"><a>EventHandler</a></span></dt>
              <dd>
                <p>This event handler, of type <a>isolationchange</a>, is fired
                when the value of the <var>isolated</var> attribute
                changes.</p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
      <section id="isolated-pc">
        <h4>Isolated Streams and RTCPeerConnection</h4>
        <p>A <code>MediaStreamTrack</code> with a <var>peerIdentity</var>
        option set can be added to any <code><a>RTCPeerConnection</a></code>.
        However, the content of an isolated track MUST NOT be transmitted
        unless all of the following constraints are met:</p>
        <ul>
          <li>
            <p>A <code>MediaStreamTrack</code> from a stream acquired using the
            <var>peerIdentity</var> option can be transmitted if the
            <code><a>RTCPeerConnection</a></code> has successfully <a href=
            "#sec.identity-verify-assertion">validated the identity</a> of the
            peer AND that identity is the same identity that was used in the
            <var>peerIdentity</var> option associated with the track. That is,
            the <code>name</code> attribute of the <code>peerIdentity</code>
            attribute of the <code><a>RTCPeerConnection</a></code> instance
            MUST match the value of the <code>peerIdentity</code> option passed
            to <code>getUserMedia()</code>.</p>
            <p>Rules for matching identity are described in
            [[!RTCWEB-SECURITY-ARCH]].</p>
          </li>
          <li>
            <p>The peer has indicated that it will respect the isolation
            properties of streams. That is, a DTLS connection with a promise to
            respect stream confidentiality, as defined in [[!RTCWEB-ALPN]] has
            been established.</p>
          </li>
        </ul>
        <p>Failing to meet these conditions means that no media can be sent for
        the affected <code>MediaStreamTrack</code>. Video MUST be replaced by
        black frames, audio MUST be replaced by silence, and equivalently
        information-free content MUST be provided for other media types.</p>
        <p>Remotely sourced <code>MediaStreamTrack</code>s MUST be isolated if
        they are received over a DTLS connection that has been negotiated with
        track isolation. This protects isolated media from the application in
        the receiving browser. These tracks MUST only be displayed to a user
        using the appropriate media element (e.g., &lt;video&gt; or
        &lt;audio&gt;).</p>
        <p>Any <code>MediaStreamTrack</code> that has the
        <var>peerIdentity</var> option set causes all tracks sent using the
        same <code><a>RTCPeerConnection</a></code> to be isolated at the
        receiving peer. All DTLS connections created for a
        <code><a>RTCPeerConnection</a></code> with isolated local streams MUST
        be negotiated so that media remains isolated at the remote peer. This
        causes non-isolated media to become isolated at the receiving peer if
        any isolated tracks are added to the same
        <code><a>RTCPeerConnection</a></code>.</p>
        <p class="note">Tracks that are not bound to a particular
        <var>peerIdentity</var> do not cause other streams to be isolated,
        these tracks simply do not have their content transmitted.</p>
        <p>If a stream becomes isolated after initially being accessible, or an
        isolated stream is added to an active session, then media for that
        stream is replaced by information-free content (e.g., black frames or
        silence).</p>
      </section>
      <section id="isolation-protection">
        <h4>Protection Afforded by Media Isolation</h4>
        <p>Media isolation ensures that the content of a
        <code>MediaStreamTrack</code> is not accessible to web applications.
        However, to ensure that media with a <var>peerIdentity</var> option set
        can be sent to peers, some meta-information about the media will be
        exposed to applications.</p>
        <p>Applications will be able to observe the parameters of the media
        that affect session negotiation and conversion into RTP. This includes
        the codecs that might be supported by the track, the bitrate, the
        number of packets, and the current settings that are set on the
        <code>MediaStreamTrack</code>.</p>
        <p>In particular, the <a href="#sec.stats-model">statistics</a> that
        <code><a>RTCPeerConnection</a></code> records are not reduced in
        capability. New statistics that might compromise isolation MUST be
        avoided, or explicitly suppressed for isolated streams.</p>
        <p>Most of these data are exposed to the network when the media is
        transmitted. Only the settings for the <code>MediaStreamTrack</code>
        present a new source of information. This can includes the frame rate
        and resolution of video tracks, the bandwidth of audio tracks, and
        other information about the source, which would not otherwise be
        revealed to a network observer. Since settings don't change at a high
        frequency or in response to changes in media content, settings only
        reveal limited reveal information about the content of a track.
        However, any setting that might change dynamically in response to the
        content of an isolated <code>MediaStreamTrack</code> MUST have changes
        suppressed.</p>
      </section>
    </section>
  </section>
  <section class="informative">
    <h2>Examples and Call Flows</h2>
    <section>
      <h3>Simple Peer-to-peer Example</h3>
      <div>
        <p>When two peers decide they are going to set up a connection to each
        other, they both go through these steps. The STUN/TURN server
        configuration describes a server they can use to get things like their
        public IP address or to set up NAT traversal. They also have to send
        data for the signaling channel to each other using the same out-of-band
        mechanism they used to establish that they were going to communicate in
        the first place.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;

// call start() to initiate
function start() {
    pc = new RTCPeerConnection(configuration);

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    // once remote video track arrives, show it in the remote video element
    pc.ontrack = function (evt) {
        if (evt.track.kind === "video")
          remoteView.srcObject = evt.streams[0];
    };

    // get a local stream, show it in a self-view and add it to be sent
    navigator.mediaDevices.getUserMedia({ "audio": true, "video": true })
        .then(function (stream) {
            selfView.srcObject = stream;
            pc.addTrack(stream.getAudioTracks()[0], stream);
            pc.addTrack(stream.getVideoTracks()[0], stream);
        })
        .catch(logError);
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        start();

    var message = JSON.parse(evt.data);
    if (message.desc) {
        var desc = message.desc;

        // if we get an offer, we need to reply with an answer
        if (desc.type == "offer") {
            pc.setRemoteDescription(desc).then(function () {
                return pc.createAnswer();
            })
            .then(function (answer) {
                return pc.setLocalDescription(answer);
            })
            .then(function () {
                var str = JSON.stringify({ "desc": pc.localDescription });
                signalingChannel.send(str);
            })
            .catch(logError);
        } else if (desc.type == "answer") {
            pc.setRemoteDescription(desc).catch(logError);
        } else {
            log("Unsupported SDP type. Your code may differ here.");
        }
    } else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div>
    </section>
    <section>
      <h3>Simple Peer-to-peer Example with Warm-up</h3>
      <div>
        <p>When two peers decide they are going to set up a connection to each
        other and want to have the ICE, DTLS, and media connections "warmed up"
        such that they are ready to send and receive media immediately, they
        both go through these steps.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;
var audio = null;
var audioSendTrack = null;
var video = null;
var videoSendTrack = null;
var started = false;

// Call warmp() to warm-up ICE, DTLS, and media, but not send media yet.
function warmup(answerer) {
    pc = new RTCPeerConnection(configuration);
    if (!answerer) {
      audio = pc.addTransceiver("audio");
      video = pc.addTransceiver("video");
    }

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    // once remote video track arrives, show it in the remote video element
    pc.ontrack = function (evt) {
        if (evt.track.kind === "audio") {
          if (answerer) {
            audio = evt.transceiver;
            audio.setDirection("sendrecv");
            if (started &amp;& audioSendTrack) {
              audio.sender.replaceTrack(audioSendTrack);
            }
          }
        } else if (evt.track.kind === "video") {
          if (answerer) {
            video = evt.transceiver;
            video.setDirection("sendrecv");
            if (started &amp;& videoSendTrack) {
              video.sender.replaceTrack(videoSendTrack);
            }
          }
          remoteView.srcObject = evt.streams[0];
        }
    };

    // get a local stream, show it in a self-view and add it to be sent
    navigator.mediaDevices.getUserMedia({ "audio": true, "video": true })
      .then(function (stream) {
        selfView.srcObject = stream;
        sendAudioTrack = stream.getVideoTracks()[0];
        if (started) {
          audio.sender.replaceTrack(sendAudioTrack);
        }
        sendVideoTrack = stream.getVideoTracks()[0];
        if (started) {
          video.sender.replaceTrack(sendVideoTrack);
        }
      })
      .catch(logError);
}

// Call start() to start sending media.
function start() {
  started = true;
  signalingChannel.send(JSON.stringify({ "start": true }));
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        warmup(true);

    var message = JSON.parse(evt.data);
    if (message.desc) {
        var desc = message.desc;

        // if we get an offer, we need to reply with an answer
        if (desc.type == "offer") {
            pc.setRemoteDescription(desc).then(function () {
                return pc.createAnswer();
            })
            .then(function (answer) {
                return pc.setLocalDescription(answer);
            })
            .then(function () {
                var str = JSON.stringify({ "desc": pc.localDescription });
                signalingChannel.send(str);
            })
            .catch(logError);
        } else
            pc.setRemoteDescription(desc).catch(logError);
    } else if (message.start) {
      started = true;
      if (audio &amp;& sendAudioTrack) {
        audio.sender.replaceTrack(sendVideoTrack);
      }
      if (video &amp;& sendVideoTrack) {
        video.sender.replaceTrack(sendVideoTrack);
      }
    } else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div>
    </section>
    <section>
      <h3>Simple Peer-to-peer Example with media before signaling</h3>
      <div>
        <p>The answerer may wish to send media in parallel with sending the
        answer, and the offerer may wish to render the media before the answer
        arrives.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;

// call start() to initiate
function start() {
    pc = new RTCPeerConnection(configuration);

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    // get a local stream, show it in a self-view and add it to be sent
    navigator.mediaDevices.getUserMedia({ "audio": true, "video": true })
        .then(function (stream) {
            selfView.srcObject = stream;
            var remoteStream = new MediaStream();
            var audioSender = pc.addTrack(stream.getAudioTracks()[0], stream);
            var videoSender = pc.addTrack(stream.getVideoTracks()[0], stream);
            [audioSender, videoSender].forEach(function(sender) {
                remoteStream.addTrack(pc.getReceivers.find(function (receiver) {
                    return receiver.mid == sender.mid;
                }).track);
            });

            // Render the media even before ontrack fires.
            remoteView.srcObject = remoteStream;
        })
        .catch(logError);
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        start();

    var message = JSON.parse(evt.data);
    if (message.desc) {
        var desc = message.desc;

        // if we get an offer, we need to reply with an answer
        if (desc.type == "offer") {
            pc.setRemoteDescription(desc).then(function () {
                return pc.createAnswer();
            })
            .then(function (answer) {
                return pc.setLocalDescription(answer);
            })
            .then(function () {
                var str = JSON.stringify({ "desc": pc.localDescription });
                signalingChannel.send(str);
            })
            .catch(logError);
        } else
            pc.setRemoteDescription(desc).catch(logError);
    } else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div>
    </section>
    <section>
      <h3>Simple Simulcast Example</h3>
      <div>
        <p>A client wants to send multiple RTP encodings (simulcast) to a
        server.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;

// call start() to initiate
function start() {
    pc = new RTCPeerConnection(configuration);

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    // get a local stream, show it in a self-view and add it to be sent
    navigator.mediaDevices.getUserMedia({ "audio": true, "video": true })
        .then(function (stream) {
            selfView.srcObject = stream;
            pc.addTransceiver(stream.getAudioTracks()[0], {direction: "sendonly"});
            pc.addTransceiver(stream.getVideoTracks()[0], {
                direction: "sendonly",
                sendEncodings: [
                    {
                      rid: "f",
                    },
                    {
                      rid: "h",
                      scaleDownResolutionBy: 2.0
                    },
                    {
                      rid: "q",
                      scaleDownResolutionBy: 4.0
                    }
                ]
            });
        })
        .catch(logError);
}

signalingChannel.onmessage = function (evt) {
    var message = JSON.parse(evt.data);
    if (message.desc)
        pc.setRemoteDescription(message.desc).catch(logError);
    else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div>
    </section>
    <section>
      <h3>Advanced Peer-to-peer Example</h3>
      <div>
        <p>This example shows the more complete functionality.</p>
        <p class="issue">TODO</p>
        <pre class="example highlight">
</pre>
      </div>
    </section>
    <section>
      <h3>Peer-to-peer Data Example</h3>
      <div>
        <p>This example shows how to create a
        <code><a>RTCDataChannel</a></code> object and perform the offer/answer
        exchange required to connect the channel to the other peer. The
        <code><a>RTCDataChannel</a></code> is used in the context of a simple
        chat application and listeners are attached to monitor when the channel
        is ready, messages are received and when the channel is closed.</p>
        <pre class="example highlight">
var signalingChannel = new SignalingChannel();
var configuration = { "iceServers": [{ "urls": "stuns:stun.example.org" }] };
var pc;
var channel;

// call start(true) to initiate
function start(isInitiator) {
    pc = new RTCPeerConnection(configuration);

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // let the "negotiationneeded" event trigger offer generation
    pc.onnegotiationneeded = function () {
        pc.createOffer().then(function (offer) {
            return pc.setLocalDescription(offer);
        })
        .then(function () {
            // send the offer to the other peer
            signalingChannel.send(JSON.stringify({ "desc": pc.localDescription }));
        })
        .catch(logError);
    };

    if (isInitiator) {
        // create data channel and setup chat
        channel = pc.createDataChannel("chat");
        setupChat();
    } else {
        // setup chat on incoming data channel
        pc.ondatachannel = function (evt) {
            channel = evt.channel;
            setupChat();
        };
    }
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        start(false);

    var message = JSON.parse(evt.data);
    if (message.desc) {
        var desc = message.desc;

        // if we get an offer, we need to reply with an answer
        if (desc.type == "offer") {
            pc.setRemoteDescription(desc).then(function () {
                return pc.createAnswer();
            })
            .then(function (answer) {
                return pc.setLocalDescription(answer);
            })
            .then(function () {
                var str = JSON.stringify({ "desc": pc.localDescription });
                signalingChannel.send(str);
            })
            .catch(logError);
        } else
            pc.setRemoteDescription(desc).catch(logError);
    } else
        pc.addIceCandidate(message.candidate).catch(logError);
};

function setupChat() {
    channel.onopen = function () {
        // e.g. enable send button
        enableChat(channel);
    };

    channel.onmessage = function (evt) {
        showChatMessage(evt.data);
    };
}

function sendChatMessage(msg) {
    channel.send(msg);
}

function logError(error) {
    log(error.name + ": " + error.message);
}

</pre>
      </div><!--div>
    <p>This simple example shows how configure two RTCDataChannel objects for different purposes.</p>
<p><pre   class='example highlight'>
// the chat channel is reliable and not as prioritized as game data
var chatChan = peerConn.createDataChannel("chat", { "priority": 1 });

// the game data channel is prioritized and unreliable low latency channel for high performance
var gameDataChan = peerConn.createDataChannel("data", { "reliable": false, "priority": 10 });
    </pre></p>
  </div-->
    </section>
    <section>
      <h3>Call Flow Browser to Browser</h3>
      <p class="issue">Editors' Note: This example flow needs to be discussed
      on the list and is likely wrong in many ways.</p>
      <p>This shows an example of one possible call flow between two browsers.
      This does not show the procedure to get access to local media or every
      callback that gets fired but instead tries to reduce it down to only show
      the key events and messages.</p>
      <p><img alt=
      "A message sequence chart detailing a call flow between two browsers"
      src="images/ladder-2party-simple.svg" style="width:100%"></p><!--
      <p>The following flow shows a more complete set of the callbacks and
      events that happen.</p>

      <p><img alt=
      "A more complete message sequence chart detailing a call flow between two browsers"
      src="images/ladder-2party-full.svg" style="width:100%"></p>
      -->
    </section>
    <section>
      <h3>DTMF Example</h3>
      <p>Examples assume that <var>sender</var> is an RTCRtpSender.</p>
      <p>Sending the DTMF signal "1234" with 500 ms duration per tone:</p>
      <pre class="example highlight">if (sender.dtmf) {
    var duration = 500;
    sender.dtmf.insertDTMF("1234", duration);
} else
    log("DTMF function not available");

</pre>
      <p>Send the DTMF signal "1234", and light up the active key using
      <code>lightKey(key)</code> while the tone is playing (assuming that
      <code>lightKey("")</code> will darken all the keys):</p>
      <pre class="example highlight">if (sender.dtmf) {
  sender.dtmf.ontonechange = function (e) {
      if (!e.tone)
          return;
      // light up the key when playout starts
      lightKey(e.tone);
      // turn off the light after tone duration
      setTimeout(lightKey, sender.duration, "");
  };
  sender.dtmf.insertDTMF("1234");
} else
    log("DTMF function not available");

</pre>
      <p>Send a 1-second "1" tone followed by a 2-second "2" tone:</p>
      <pre class="example highlight">if (sender.dtmf) {
  sender.dtmf.ontonechange = function (e) {
      if (e.tone == "1")
          sender.dtmf.insertDTMF("2", 2000);
  };
  sender.dtmf.isertDTMF("1", 1000);
} else
    log("DTMF function not available");

</pre>
      <p>It is always safe to append to the tone buffer. This example appends
      before any tone playout has started as well as during playout.</p>
      <pre class="example highlight">
if (sender.dtmf) {
  sender.dtmf.insertDTMF("123");
  // append more tones to the tone buffer before playout has begun
  sender.dtmf.insertDTMF(sender.toneBuffer + "456");

  sender.dtmf.ontonechange = function (e) {
      if (e.tone == "1")
          // append more tones when playout has begun
          sender.dtmf.insertDTMF(sender.toneBuffer + "789");
  };
} else
    log("DTMF function not available");

</pre>
      <p>Send the DTMF signal "123" and abort after sending "2".</p>
      <pre class="example highlight">if (sender.dtmf) {
  sender.dtmf.ontonechange = function (e) {
      if (e.tone == "2")
          // empty the buffer to not play any tone after "2"
          sender.dtmf.insertDTMF("");
  };
  sender.dtmf.insertDTMF("123");
} else
    log("DTMF function not available");
</pre>
    </section><!--
    <section>
      <h3>Call Flow Browser to MCU</h3>

      <p class="note">Editors' Note: This example flow needs to be discussed on
      the list and is likely wrong in many ways.</p>

      <p>This shows an example of one possible call flow between a centralized
      conferencing server and a browser. This does not show every callback that
      gets fired but instead tries to reduce it down to only show the key
      events and messages.</p>

      <p><img alt=
      "A message sequence chart detailing a call flow between a browser and a centralized conferencing server"
      src="images/ladder-mcu-simple.svg" style="width:100%"></p>
    </section>
-->
  </section>
  <section class="informative">
    <h2>Event summary</h2>
    <p>The following events fire on <code><a>RTCDataChannel</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-datachannel-open"><code>open</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code><a>RTCDataChannel</a></code> object's <a>underlying data
            transport</a> has been established (or re-established).
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-datachannel-message"><code>message</code></dfn></td>
          <td><code><a href=
          "http://www.w3.org/TR/webmessaging/#the-messageevent-interfaces">MessageEvent</a></code>
          [[!webmessaging]]</td>
          <td>A message was successfully received.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-datachannel-bufferedamountlow"><code>bufferedamountlow</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCDataChannel</a></code> object's
          <code><a data-for="RTCDataChannel">bufferedAmount</a></code>
          decreases from above its <code><a data-for=
          "RTCDataChannel">bufferedAmountLowThreshold</a></code> to less than
          or equal to its <code><a data-for=
          "RTCDataChannel">bufferedAmountLowThreshold</a></code>.</td>
        </tr>
        <tr>
          <td><code>error</code></td>
          <td><code><a>ErrorEvent</a></code></td>
          <td>Any error occured from the data channel.</td>
        </tr>
        <tr>
          <td><dfn id="event-datachannel-close"><code>close</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code><a>RTCDataChannel</a></code> object's <a>underlying data
            transport</a> has bee closed.
          </td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCPeerConnection</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id=
          "event-mediastream-connecting"><code>connecting</code></dfn></td>
          <td><code>Event</code></td>
          <td>
            <p class="issue">TODO</p>
          </td>
        </tr><!--
        <tr>
          <td><dfn title="event-MediaStream-error"><code>error</code></dfn></td>
          <td><code>Event</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="event-MediaStream-close"><code>close</code></dfn></td>
          <td><code>Event</code></td>
          <td>The <code title="dom-RTCPeerConnection-close">close()</code> method was
            called. </td>
        </tr>
        <tr>
          <td>
            <dfn id="event-mediastream-message">
              <code>message</code>
            </dfn>
          </td>

          <td>
            <code>MessageEvent</code>
          </td>

          <td>A <a href="#data-udp-media-stream">data UDP media
          stream</a> message was received.</td>
        </tr>
        -->
        <tr>
          <td><dfn id="event-track"><code>track</code></dfn></td>
          <td><code><a>RTCTrackEvent</a></code></td>
          <td>
            A new incoming <code>MediaStreamTrack</code> has been created, and
            an associated <code>RTCRtpReceiver</code> has been added to the
            set of receivers.
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-negotiation"><code>negotiationneeded</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The browser wishes to inform the application that session
          negotiation needs to be done (i.e. a createOffer call followed by
          setLocalDescription).</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-signalingstatechange"><code>signalingstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <a>signaling state</a> has changed. This state change is the
            result of either <code><a data-for=
            "RTCPeerConnection">setLocalDescription</a></code> or
            <code><a data-for=
            "RTCPeerConnection">setRemoteDescription</a></code> being invoked.
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-iceconnectionstatechange"><code>iceconnectionstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code>RTCPeerConnection</code>'s <a>ICE connection state</a>
            has changed.
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-icegatheringstatechange"><code>icegatheringstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code>RTCPeerConnection</code>'s <a>ICE gathering state</a> has
            changed.
          </td>
        </tr>
        <tr>
          <td><dfn id="event-icecandidate"><code>icecandidate</code></dfn></td>
          <td><code><a>RTCPeerConnectionIceEvent</a></code></td>
          <td>A new <code><a>RTCIceCandidate</a></code> is made available to
          the script.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-connectionstatechange"><code>connectionstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code>RTCPeerConnection</code> <a data-for="RTCPeerConnection"
            data-link-for="RTCPeerConnection">connectionState</a> has changed.
          </td>
        </tr>
        <tr>
          <td><dfn id=
          "event-icecandidateerror"><code>icecandidateerror</code></dfn></td>
          <td><code><a>RTCPeerConnectionIceErrorEvent</a></code></td>
          <td>A failure occured when gathering ICE candidates.</td>
        </tr>
        <tr>
          <td><dfn id="event-datachannel"><code>datachannel</code></dfn></td>
          <td><code><a>RTCDataChannelEvent</a></code></td>
          <td>A new <code><a>RTCDataChannel</a></code> is dispatched to the
          script in response to the other peer creating a channel.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-isolationchange"><code>isolationchange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>A new <code><a>Event</a></code> is dispatched to the script when
          the <var>isolated</var> attribute on a <code>MediaStreamTrack</code>
          changes.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCDTMFSender</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id=
          "event-RTCDTMFSender-tonechange"><code>tonechange</code></dfn></td>
          <td><code><a>RTCDTMFToneChangeEvent</a></code></td>
          <td>The <code><a>RTCDTMFSender</a></code> object has either just
          begun playout of a tone (returned as the <code><a data-link-for=
          "RTCDTMFToneChangeEvent">tone</a></code> attribute) or just ended
          playout of a tone (returned as an empty value in the
          <code><a data-link-for="RTCDTMFToneChangeEvent">tone</a></code>
          attribute).</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCIceTransport</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-icetransport-statechange" data-lt=
          "RTCIceTransport state change"><code>statechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCIceTransport</a></code> state changes.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-icetransport-gatheringstatechange"><code>gatheringstatechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCIceTransport</a></code> gathering state
          changes.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-icetransport-selectedcandidatepairchange"><code>selectedcandidatepairchange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCIceTransport</a></code>'s selected candidate pair
          changes.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCDtlsTransport</a></code>
    objects:</p>
    <table>
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-dtlstransport-statechange" data-lt=
          "RTCDtlsTransport state change" data-lt-nodefault=
          ""><code>statechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCDtlsTransport</a></code> state changes.</td>
        </tr>
      </tbody>
    </table>
  </section>
  <section class="informative">
    <h2>Privacy and Security Considerations</h2>
    <p>This section is non-normative; it specifies no new behaviour, but
    instead summarizes information already present in other parts of the
    specification. The overall security considerations of the general set of
    APIs and protocols used in WebRTC are described in
    [[RTCWEB-SECURITY-ARCH]].</p>
    <section>
      <h2>Impact on same origin policy</h2>
      <p>This document extends the Web platform with the ability to set up real
      time, direct communication between browsers and other devices, including
      other browsers.</p>
      <p>This means that data and media can be shared between applications
      running in different browsers, or between an application running in the
      same browser and something that is not a browser, something that is an
      extension to the usual barriers in the Web model against sending data
      between entities with different origins.</p>
      <p>The WebRTC specification provides no user prompts or chrome indicators
      for communication; it assumes that once the Web page has been allowed to
      access media, it is free to share that media with other entities as it
      chooses. Peer-to-peer exchanges of data view WebRTC datachannels can thus
      occur without any user explicit consent or involvement, similarly as a
      server-mediated exchange (e.g. via Web Sockets) could occur without user
      involvement.</p>
      <p>The <code><a>peerIdentity</a></code> mechanism loads and executes
      JavaScript code from a third-party server acting as an identity provider.
      That code is executed in a separate JavaScript realm and does not affect
      the protections afforded by the same origin policy.</p>
    </section>
    <section>
      <h2>Revealing IP addresses</h2>
      <p>Even without WebRTC, the Web server providing a Web application will
      know the public IP address to which the application is delivered. Setting
      up communications exposes additional information about the
      browser&#8217;s network context to the web application, and may include
      the set of (possibly private) IP addresses available to the browser for
      WebRTC use. Some of this information has to be passed to the
      corresponding party to enable the establishment of a communication
      session.</p>
      <p>Revealing IP addresses can leak location and means of connection; this
      can be sensitive. Depending on the network environment, it can also
      increase the fingerprinting surface and create persistent cross-origin
      state that cannot easily be cleared by the user.</p>
      <p>A connection will always reveal the IP addresses proposed for
      communication to the corresponding party. The application can limit this
      exposure by choosing not to use certain addresses using the settings
      exposed by the <a>RTCIceTransportPolicy</a> dictionary, and by using
      relays (for instance TURN servers) rather than direct connections between
      participants. One will normally assume that the IP address of TURN
      servers is not sensitive information. These choices can for instance be
      made by the application based on whether the user has indicated consent
      to start a media connection with the other party.</p>
      <p>Mitigating the exposure of IP addresses to the application itself
      requires limiting the IP addresses that can be used, which will impact
      the ability to communicate on the most direct path between endpoints.
      Browsers are encouraged to provide appropriate controls for deciding
      which IP addresses are made available to applications, based on the
      security posture desired by the user. The choice of which addresses to
      expose is controlled by local policy (see [[RTCWEB-IP-HANDLING]] for
      details).</p>
    </section>
    <section>
      <h2>Impact on local network</h2>
      <p>Since the browser is an active platform executing in a trusted network
      environment (inside the firewall), it is important to limit the damage
      that the browser can do to other elements on the local network, and it is
      important to protect data from interception, manipulation and
      modification by untrusted participants.</p>
      <p>Mitigations include:</p>
      <ul>
        <li>An UA will always request permission from the correspondent UA to
        communicate using ICE. This ensures that the UA can only send to
        partners who you have shared credentials with.</li>
        <li>An UA will always request ongoing permission to continue sending
        using ICE continued consent. This enables a receiver to withdraw
        consent to receive.</li>
        <li>An UA will always encrypt data, with strong per-session keying
        (DTLS-SRTP).</li>
        <li>An UA wil always use congestion control. This ensures that WebRTC
        cannot be used to flood the network.</li>
      </ul>
      <p>These measures are specified in the relevant IETF documents.</p>
    </section>
    <section>
      <h2>Confidentiality of Communications</h2>
      <p>The fact that communication is taking place cannot be hidden from
      adversaries that can observe the network, so this has to be regarded as
      public information.</p>
      <p>A mechanism, <code><a>peerIdentity</a></code>, is provided that gives
      Javascript the option of requesting media that the same javascript cannot
      access, but can only be sent to certain other entities.</p>
    </section>
    <section>
      <h2>Persistent information exposed by WebRTC</h2>
      <p>As described above, the list of IP addresses exposed by the WebRTC API
      can be used as a persistent cross-origin state.</p>
      <p>Beyond IP addresses, the WebRTC API exposes information about the
      underlying media system via the <code>RTCRtpSender.getCapabilities</code>
      and <code>RTCRtpReceiver.getCapabilities</code> methods, including
      detailed and ordered information about the codecs that the system is able
      to produce and consume. A subset of that information is likely to be
      represented in the SDP session descriptions generated, exposed and
      transmitted during <a href="#session-negotiation-model">session
      negotiation</a>. That information is in most cases persistent across time
      and origins, and increases the fingerprint surface of a given device.</p>
      <p>If set, the configured default ICE servers exposed by
      <a data-for="RTCPeerConnection">defaultIceServers</a> on
      <code>RTCPeerConnection</code> instances also provides persistent across
      time and origins information which increases the fingerprinting surface
      of a given browser.</p>
      <p>When establishing DTLS connections, the WebRTC API can generate
      certificates that can be persisted by the application (e.g. in
      IndexedDB). These certificates are not shared across origins, and get
      cleared when persistent storage is cleared for the origin.</p>
    </section>
  </section><!--section>
    <h2 id="sec-iana">IANA Registrations</h2>



    <p>IANA is requested to register the constraints defined in <a href=
    "#sec-constraints">Constraints Section</a> as specified in
    [[!RTCWEB-CONSTRAINTS]].</p>


    <section>
      <h3 id="sec-constraints">Constraints</h3>


      <p>TOOD: Need to change the naming and declaration of these constraints
      to match the constraints draft once that is a bit further along. The
      names here now are likely not quite right but they serve as a place
      holder.</p>


      <p class="issue">ISSUE: there are multiple ways to add constraints. How
      are multiple values reconciled?</p>


      <p>The following new constraints are defined that can be used with an
      <code>RTCPeerConnection</code> object:</p>


      <p>TODO items - need to register with IANA.</p>
    </section>
  </section-->
  <section>
    <h2>Change Log</h2>
    <p>This section will be removed before publication.</p>
    <!-- Why do the first two headings automatically convert to <h2>? -->
    <!-- Because you haven't added a <section> element around them
         and respec rewrites h? elements based on the section depth -->
    <h3>Changes since July 22, 2016</h3>
    <ol>
      <li>[#713] Missing destruction sequence for ICE Agent</li>
      <li>[#730] Revised WebRTC 1.0 RTCIceTransportState transition diagram</li>
      <li>[#722] How setDirection interacts with active/inactive
      sender/receivers</li>
      <li>[#716] Improve error handling for IdP proxy interactions</li>
      <li>[#719] The IdP environment can be spoofed</li>
      <li>[#733] Clarification on RTX in Codec Capabilities/Parameters</li>
      <li>[#734] RTCRtpEncodingParameters attribute to turn on/off sending
      CN/DTX</li>
      <li>[#737] Fix mistakes in examples</li>
      <li>[#739] Replace set of senders/receivers/transceivers with
      algorithms</li>
      <li>[#721] Specify the synchronous and queued steps for
      addIceCandidate</li>
      <li>[#759] Clarification on receipt of multiple RTP encodings</li>
      <li>[#758] Support replaceTrack with the previous track ended</li>
      <li>[#745] Add steps to createOffer and explicitly specify what is
      queued</li>
      <li>[#762] Remove closed check from addIceCandidate steps (covered by
      enqueue steps)</li>
      <li>[#750] RTCIdentityProviderGlobalScope needs Exposed attributes</li>
      <li>[#752] Add steps to createAnswer and explicitly specify what is
      queued</li>
      <li>[#756] Integrate queueing into the setLocal/RemoteDescription
      steps</li>
      <li>[#765] Adding more detail to the definition of the ICE `disconnected`
      state.</li>
      <li>[#778] Remove void conformance requirement on interToneGap</li>
      <li>[#779] Make duration and interToneGap attributes unsigned long</li>
    </ol>
    <h3>Changes since May 13, 2016</h3>
    <ol>
      <li>[#640, #641, #659, #679, #680, #681, #682, #686, #694,
          #696, #697, #707, #708, #711] General editorial fixes</li>
      <li>[#642] Editorial: make last arg of addTransceiver optional</li>
      <li>[#643] Document defaultIceServers as source of
      fingerprinting</li>
      <li>[#646] Create table of RTCRtpEncodingParameters for
      RtpSender/RtpReceiver</li>
      <li>[#648] Clarify MIME (media/sub-) type</li>
      <li>[#649] Example of how to do hold</li>
      <li>[#662] Clarify effect of RTCRtpReceiver.track.stop()</li>
      <li>[#663] Define a 7XX STUN error code</li>
      <li>[#665] Clarify when setDirection() acts</li>
      <li>[#666] Clarify that transports can be null</li>
      <li>[#676] Transceiver.stop() causes negotiationneeded to be set</li>
      <li>[#677] Clean up rtcpTransport description</li>
      <li>[#701] In addTrack, mention that MSID of new track is added</li>
      <li>[#702, #704] Define algs for creating sender/receiver/transceiver,
      then use them in addTrack() and addTransceiver()</li>
      <li>[#725] Change 'process to apply candidate' to 'add the ICE
      candidate'</li>
    </ol>
    <h3>Changes since February 15, 2016</h3>
    <ol>
      <li>[#475] Definition of Active for an RTCRtpReceiver</li>
      <li>[#500] Reserve and use RangeError for scaleResolutionDownBy <
      1.0</li>
      <li>[#504] Add getParameters() method to RTCRtpReceiver</li>
      <li>[#509] RID unmodifiable in setParameters()</li>
      <li>[#510] Gather spec text about the ICE Agent at one
      place</li>
      <li>[#512] Use 'connection' as configuration target instead of User
      Agent</li>
      <li>[#505] Add activateReceiver method to RTCRtpTransceiver</li>
      <li>[#516] Support for DTMF tones A-D</li>
      <li>[#499] Certificate API: add getAlgorithm method</li>
      <li>[#507] Make the definition of addIceCandidate() more explicit</li>
      <li>[#525] Add STUN Error Code reference</li>
      <li>[#524] Add error codes reference (RTCPeerConnectionIceErrorEvent)
      </li>
      <li>[#522] Let setting ice candidate pool size trigger start of
      gathering</li>
      <li>[#519] Relation between local track and outgoing encoding</li>
      <li>[#520] Add text about 'remote sources' and how they are stopped</li>
      <li>[#527] Enable trickling of end-of-candidates through addIceCandidate
      </li>
      <li>[#544] Remove "public" from ice transport policy</li>
      <li>[#547] Datachannel label and protocol are USVString</li>
      <li>[#552] Never close the RTCPeerConnection if setting a local/remote
      description fails</li>
      <li>[#535] Update MID to be random values when not received in offer</li>
      <li>[#553] Move 'closed' state from RTCSignalingState to
      RTCPeerConnectionState</li>
      <li>[#557] Splitting apart RTCIceConnectionState and
      RTCIceTransportState</li>
      <li>[#560] Changing from callback interface to dictionary for
      RTCIdentityProvider</li>
      <li>[#574] Make RTCSessionDescription readonly, and createOffer return
      dictionary</li>
      <li>[#577] Make RtpSender.track nullable</li>
      <li>[#587] Defining how track settings are set for remote tracks</li>
      <li>[#603] Add closed state and same state checks to update ice
      connection/gathering state steps</li>
      <li>[#604] ReplaceTrack: Use sender's transceiver to determine if a
      'simple track swap' is enough</li>
      <li>[#606] RTCIceCandidate: Use nullable members in init dictionary to
      describe constructor behavior</li>
      <li>[#466] Use an enum to describe directionality of RTP Stream</li>
      <li>[#602] addTransceiver(): Throw a TypeError on a bogus track kind</li>
      <li>[#610] Server cannot be reached - Issues with IPv6</li>
      <li>[#611] Clarify ICE consent freshness feedback</li>
      <li>[#618] Fix RTCPeerConnection legacy overloads</li>
      <li>[#620] RTCRtpTransceiver: add setDirection and readonly direction
      attribute</li>
      <li>[#625] Unifiy DTMF time with rtcweb WG</li>
      <li>[#630] Add ICE candidate type references</li>
      <li>[#635] pc.addTrack: Add kind check when reusing a sender and skip
      early returns</li>
      <li>[#636] replaceTrack: Use 'transceiver kind' instead of track.kind
      (track may be null)</li>
    </ol>
    <h3>Changes since January 26, 2016</h3>
    <ol>
      <li>[#485] Update SOTD as the document is now quite stable and the group
      is looking for wide review</li>
      <li>[#468, #335] Replace DOMError with DOMException</li>
      <li>[#472, #319] Update error reports to align with existing DOM
      Errors</li>
      <li>[#491, #479] Specify error when rejecting invalid SDP changes</li>
      <li>[#462] Add PeerConnection.activateSender() and update early media
      example</li>
      <li>[#434] Change setParameters call to be Async</li>
    </ol>
    <h3>Changes since December 22, 2015</h3>
    <ol>
      <li>[#179, #439] Document IP address leakage in RTCIceCandidate</li>
      <li>[#439] Complete security considerations based on security
      questionnaire and IP address discussions #439</li>
      <li>[#446] Non-nullable RTCTrackEvent args means Init dict members are
      required</li>
      <li>[#449] Clarify flow of SDP exchanges (Update simple p2p example)</li>
      <li>[#451] Clean up event handler attribute descriptions</li>
      <li>[#452, #438] Make replaceTrack() handle "not sending yet" case</li>
      <li>[#454] Add contributing source voice activity flag</li>
      <li>[#455, #439] Add references to parsing stun/turn URLs section</li>
      <li>[#456, #338] SDP changes between the createOffer and
      setLocalDescription (add JSEP reference)</li>
      <li>[#459] Add non-normative ICE state transitions</li>
      <li>[#460, #461] getRemoteCertificates() behavior in "new" and
      "connecting" states</li>
      <li>[#465, #140] Use ErrorEvent as interface for events emitted by
      RTCDataChannel.onerror</li>
      <li>[#469, #382, #373] Reject changes to peerIdentity and certificates in
      setConfiguration</li>
      <li>[#474, #406] Define RTCIceTransport.component when RTP/RTCP mux is in
      use</li>
    </ol>
    <h3>Changes since November 23, 2015</h3>
    <ol>
      <li>[#353] Plan X: Add an API for using RID to do simulcast</li>
      <li>[#365] Adding an accessor for the browser-configured ICE servers</li>
      <li>[#398] Make RtpTransceiver.mid nullable and remove RtpSender.mid and
      RtpReceiver.mid</li>
      <li>[#402, #391] Remove requirement about DTMF tones A-D</li>
      <li>[#403, #377] Use positive values for AudioLevel</li>
      <li>[#401, #267] Add bitrate definition</li>
      <li>[#404] Remove 'Events on MediaStream' section (duplicates new text in
      Media Capture spec)</li>
      <li>[#410, #328] Make RTCBundlePolicy Enum section normative</li>
      <li>[#411, #408] Clarify component for IceTransport when RTP/RTCP mux is
      used</li>
      <li>[#414] Define ReSpec processor for cross-reference to JSEP</li>
      <li>[#418] Make degradationPreference per-sender instead of
      per-encoding</li>
      <li>[#416] RTCRtpSender.replaceTrack() fixes (e.g. handle closed
      RTCPeerConnection)</li>
      <li>[#421] Require sdp in RTCSessionDescription{,Init}</li>
      <li>[#422] Remove confusing paragraph on fourth party interception</li>
      <li>[#423] Add specific references to JSEP where possible</li>
      <li>[#428] Don't create a default stream in 'dispatch a receiver'
      steps</li>
      <li>[#429] Adding expires attribute to generateCertificate</li>
      <li>[#430] Add maxFramerate knob for simulcast</li>
      <li>[#432] Update RTCIceTransportPolicy</li>
      <li>[#433] Use unsigned long ssrc in stats</li>
      <li>[#424] Editorial: Distinguish states from their attribute
      representation</li>
    </ol>
    <h3>Changes since October 6, 2015</h3>
    <ol>
      <li>[#325] Adding additional members to RTCIceCandidate dictionary</li>
      <li>[#327] Adding sha-256 to the certificate management options for
      RSA</li>
      <li>[#342] Using DOMTimestamp for RTCCertificate::expires</li>
      <li>[#293] Add RTCRtpTransceiver and PeerConnection.addMedia</li>
      <li>[#366, #343] Use RTCDegradationPreference</li>
      <li>[#374] Throw on too long label/protocol in createDataChannel()</li>
      <li>[#266] Tidy up setLocal/RemoteDescription processing model</li>
      <li>[#361] Adding setCodecPreferences to RTCRtpTransceiver</li>
      <li>[#371] Add RtcpMuxPolicy</li>
      <li>[#385, #312] Don't invoke public API in legacy function section</li>
      <li>[#394, #393] don't throw on empty iceServers list</li>
    </ol>
    <h3>Changes since September 22, 2015</h3>
    <ol>
      <li>[#289, #153] Add way to set size of ICE candidate pool</li>
      <li>[#256] Fix prose on getStats() wo/selector + move type check to sync
      section</li>
      <li>[#242] Remove SyntaxError on malformed ICE candidate</li>
      <li>[#284] Add icecandidateerror event for indicating ICE gathering
      errors</li>
      <li>[#298] Add support for codec reordering and removal in
      RtpParameters</li>
      <li>[#311] Fixing syntax for required RTCCertificate arguments</li>
      <li>[#280] Add extra IceTransport read-only attributes and methods</li>
      <li>[#291] Add PeerConnection.connectionState</li>
      <li>[#300, #4, #6, #276] Add API to get SSRC and audio levels</li>
      <li>[#301] Fix RTCStatsReport with object and maplike instead of
      getter</li>
      <li>[#302] (Partly) removing interface use for RTCSessionDescription and
      RTCIceCandidate</li>
      <li>[#314, #299] Update the operations queue to handle promises and
      closed signalling</li>
      <li>[#273] Add a bunch of fields to RtpParameters and
      RtpEncodingParameters</li>
    </ol>
    <h3>Changes since June 11, 2015</h3>
    <ol>
      <li>[#234] Add RTCRtpParameters, RTCRtpSender.getParameters, and
      RTCRtpSender.setParameters</li>
      <li>[#225] Support for pending and current SDP</li>
      <li>[#229] Removing the weird optionality from RTCSessionDescription and
      its constructor.</li>
      <li>[#235] Modernize getStats() with promises</li>
      <li>[#243] Mark candidate property of RTCIceCandidateInit required</li>
      <li>[#248] Fix error handling for certificate management</li>
      <li>[#259] Change type of RtpEncodingParameters.priority to an enum</li>
      <li>[#21, #262] Sort out 2119 MUSTs and SHOULDs</li>
      <li>[#268] Add RtpEncodingParameters.maxBitrate</li>
      <li>[#241] Add RtpSender.transport, RtpReceiver.transport,
      RTCDtlsTransport, RTCIceTransport, etc</li>
      <li>[#224, #261] Sort out when responding PeerConnection reaches
      iceConnetionState completed</li>
      <li>[#303] Replace track without renegotiation</li>
      <li>[#269] Add RTCRtpSender.getCapabilities and
      RTCRtpReceiver.getCapabilities</li>
    </ol>
    <h3>Changes since March 6, 2015</h3>
    <ol>
      <li>[PR #167] Removed RTCPeerConnection.createDTMFSender and added
      RTCRtpSender.dtmf, along with corresponding examples.</li>
      <li>[PR #184] RTCPeerConnection will NOT connect unless identity is
      verified.</li>
      <li>[PR #27] Documenting practice with candidate events</li>
      <li>[PR #203] Rewrote mitigations text for security considerations
      section</li>
      <li>[PR #192] Added support for auth tokens. Fixes #190</li>
      <li>[PR #207] Update ice config examples to use multiple urls and *s
      schemes</li>
      <li>[PR #210] Optional RTCConfiguration in RTCPC constructor</li>
      <li>[PR #171] Add RTCAnswerOptions (with common RTCOfferAnswerOptions
      dictionary)</li>
      <li>[PR #178] Identity provider interface redesign</li>
      <li>[PR #193] Add .mid property to sender/receiver. Fixes #191</li>
      <li>[PR #218] Enqueue addIceCandidate</li>
      <li>[PR #213 (1)] Rename updateIce() to setConfiguration()</li>
      <li>[PR #213 (2)] Make RTCPeerConnection.setConfiguration() replace the
      existing configuration</li>
      <li>[PR #214] Certificate management API (Bug 21880)</li>
      <li>[PR #220] Clarify muted state (proposed fix for issue #139)</li>
      <li>[PR #221] Define when RTCRtpReceivers are created and dispatced
      (issue #198)</li>
      <li>[PR #215] Adding expires attribute to certificate management</li>
      <li>[PR #233] Add a "bufferedamountlow" event</li>
    </ol>
    <h3>Changes since December 5, 2014</h3>
    <ol>
      <li>Properly define the negotiationneeded event, and its interactions
      with other API calls.</li>
      <li>Add support for RTCRtpSender and RTCRtpReceiver.</li>
      <li>Update misleading local/RemoteDescription attribute text.</li>
      <li>Add RTCBundlePolicy.</li>
      <li>All callback-based methods have been moved to a legacy section, and
      replaced by same-named overloads using Promises instead.</li>
      <li>[PR #194] Added first version of Security Considerations (more work
      needed)</li>
      <li>Updated identity provider structure.</li>
    </ol>
    <h3>Changes since June 4, 2014</h3>
    <ol>
      <li>Bug 25724: Allow garbage collection of closed PeerConnections</li>
      <li>Bug 27214: Add onicegatheringstatechange event</li>
      <li>Bug 26644: Fixing end of candidates event</li>
    </ol>
    <h3>Changes since April 10, 2014</h3>
    <ol>
      <li>Bug 25774: Mixed isolation</li>
    </ol>
    <h3>Changes since April 10, 2014</h3>
    <ol>
      <li>Bug 25855: Clarification about conformance requirements phrased as
      algorithms</li>
      <li>Bug 25892: SignalingStateChange event should be fired only if there
      is a change in signaling state.</li>
      <li>Bug 25152: createObjectURL used in examples is no longer supported by
      Media Capture and Streams.</li>
      <li>Bug 25976: DTMFSender.insertDTMF steps should validate the values of
      duration and interToneGap.</li>
      <li>Bug 25189: Mandatory errorCallback is missing in examples for
      getStats.</li>
      <li>Bug 25840: Creating DataChannel with same label.</li>
      <li>Updated comment above example ice state transitions (discussed in Bug
      25257).</li>
      <li>Updated insertDTMF() algorithm to ignore unrecognized characters (as
      discussed in bug 25977).</li>
      <li>Made formatting of references to ice connection state
      consistent.</li>
      <li>Made insertDTMF() throw on unrecognized characters (used to
      ignore).</li>
      <li>Removed requestIdentity from RTCConfiguration and
      RTCOfferAnswerOptions. Removed RTCOfferAnswerOptions as a result.</li>
      <li>Adding isolated property and associated event to
      MediaStreamTrack.</li>
    </ol>
    <h3>Changes since March 21, 2014</h3>
    <ol>
      <li>Changes to identity-related text:
        <ul>
          <li>Removed noaccess constraint</li>
          <li>Add the ability to peerIdentity constrain RTCPeerConnection,
          which limits communication to a single peer</li>
          <li>Change the way that the browser communicates with IdP to a
          message channel
          (http://www.w3.org/TR/webmessaging/#message-channels)</li>
          <li>Improved error feedback from IdP interactions (added new events
          with more detailed context)</li>
          <li>Changed the way that an IdP is able to request user login
          (LOGINNEEDED message)</li>
        </ul>
      </li>
      <li>Bug 25155: maxRetransmitTime is not the name of the SCTP concept it
      points to.</li>
    </ol>
    <h3>Changes since January 27, 2014</h3>
    <ol>
      <li>Refined identity assertion generation and validation.</li>
      <li>Default DTMF gap changed from 50 to 70 ms.</li>
      <li>Bug 24875: Examples in the WebRTC spec are not updated As per the
      modified API.</li>
    </ol>
    <h3>Changes since August 30, 2013</h3>
    <ol>
      <li>Make RTCPeerConnection close method be idempotent.</li>
      <li>Clarified ICE server configuration could contain URI types other than
      STUN and TURN.</li>
      <li>Changed the DTMF timing values.</li>
      <li>Allow offerToReceiveAudio/video indicate number of streams to
      offer.</li>
      <li>ACTION-98: Added text about clamping of maxRetransmitTime and
      maxRetransmits.</li>
      <li>ACTION-88: Removed nullable types from dictionaries (added attribute
      default values for attributes that would be left uninitialized without
      the init dictionary present.</li>
      <li>InvalidMediaStreamTrackError changed to InvalidParameter.</li>
      <li>Fire NetworkError when the data transport is closed with an
      error.</li>
      <li>Add an exception for data channel with trying to use existing
      code.</li>
      <li>Change maxRetransmits to be an unsigned type.</li>
      <li>Clarify state changes when ICE restarts.</li>
      <li>Added InvalidStateError exception for operations on a
      RTCPeerConnection that is closed.</li>
      <li>Major changes to Identity Proxy section.</li>
      <li>(ACTION: 95) Moved IceTransports (constraint) to RTCConfiguration
      dictionary.</li>
      <li>(ACTION: 95) Introduced RTCOfferAnswerOptions and RTCOfferOptions
      dictionaries.</li>
      <li>(ACTION: 95) Removed constraints argument from addStream() (and
      removed IANA Constraints section).</li>
      <li>Added validation of the RTCConfiguration dictionary argument(s).</li>
      <li>Added getConfiguration() on RTCPeerConnection.</li>
    </ol>
    <h3>Changes since June 3, 2013</h3>
    <ol>
      <li>Removed synchronous section left-overs.</li>
      <li>RTCIceServer now accepts multiple URLs.</li>
      <li>Redefined the meaning of negotiated for DataChannel.</li>
      <li>Made iceServers a sequence (instead of an Array).</li>
      <li>Updated error reporting (to use DOMError and camel cased names).</li>
      <li>Added success and failure callbacks to addIceCandidate().</li>
      <li>Made local/remoteDescription attributes nullable.</li>
      <li>Added username member to RTCIceServer dictionary.</li>
    </ol>
    <h3>Changes since March 22, 2013</h3>
    <ol>
      <li>Added IceRestart constraint.</li>
      <li>Big updates on DataChannel API to use new channel setup
      procedures.</li>
    </ol>
    <h3>Changes since Feb 22, 2013</h3>
    <ol>
      <li>Example review: Updated DTMF and Stats examples. Added text about
      when to fire "negotiationneeded" event to align with examples.</li>
      <li>Updated RTCPeerConnection state machine. Added a shared processing
      model for setLocalDescription()/setRemoteDescription().</li>
      <li>Updated simple callflow to match the current API.</li>
    </ol>
    <h3>Changes since Jan 16, 2013</h3>
    <ol>
      <li>Initial import of Statistics API to version 2.</li>
      <li>Integration of Statistics API version 2.5 started.</li>
      <li>Updated Statistics API to match Boston/list discussions.</li>
      <li>Extracted API extensions introduced by features, such as the P2P Data
      API, from the RTCPeerConnection API.</li>
      <li>Updated DTMF algorithm to dispatch an event when insertDTMF() is
      called with an empty string to cancel future tones.</li>
      <li>Updated DTMF algorithm to not cancel and reschedule if a playout task
      is running (only update toneBuffer and other values).</li>
    </ol>
    <h3>Changes since Dec 12, 2012</h3>
    <ol>
      <li>Changed AudioMediaStreamTrack to RTCDTMFSender and gave it its own
      section. Updated text to reflect most recent agreements. Also added
      examples section.</li>
      <li>Replaced the localStreams and remoteStreams attributes with functions
      returning sequences of MediaStream objects.</li>
      <li>Added spec text for attributes and methods adopted from the WebSocket
      interface.</li>
      <li>Changed the state ENUMs and transition diagrams.</li>
      <li>Aligned the data channel processing model a bit more with WebSockets
      (mainly closing the underlying transport).</li>
    </ol>
    <h3>Changes since Nov 13, 2012</h3>
    <ol>
      <li>Made some clarifications as to how operation queuing works, and fixed
      a few errors with the error handling description.</li>
      <li>Introduced new representation of tracks in a stream (removed
      MediaStreamTrackList). Added algorithm for creating a track to represent
      an incoming network media component.</li>
      <li>Renamed MediaStream.label to MediaStream.id (the definition needs
      some more work).</li>
    </ol>
    <h3>Changes since Nov 03, 2012</h3>
    <ol>
      <li>Added text describing the queuing mechanism for
      RTCPeerConnection.</li>
      <li>Updated simple P2P example to include all mandatory (error)
      callbacks.</li>
      <li>Updated P2P data example to include all mandatory (error) callbacks.
      Also added some missing RTC prefixes.</li>
    </ol>
    <h3>Changes since Oct 19, 2012</h3>
    <ol>
      <li>Clarified how createOffer() and createAnswer() use their
      callbacks.</li>
      <li>Made all failure callbacks mandatory.</li>
      <li>Added error object types, general error handling principles, and
      rules for when errors should be thrown.</li>
    </ol>
    <h3>Changes since Sept 23, 2012</h3>
    <ol>
      <li>Restructured the document layout and created separate sections for
      features like Peer-to-peer Data API, Statistics and Identity.</li>
    </ol>
    <h3>Changes since Aug 16, 2012</h3>
    <ol>
      <li>Replaced stringifier with serializer on RTCSessionDescription and
      RTCIceCandidate (used when JSON.stringify() is called).</li>
      <li>Removed offer and createProvisionalAnswer arguments from the
      createAnswer() method.</li>
      <li>Removed restart argument from the updateIce() method.</li>
      <li>Made RTCDataChannel an EventTarget</li>
      <li>Updated simple RTCPeerConnection example to match spec changes.</li>
      <li>Added section about RTCDataChannel garbage collection.</li>
      <li>Added stuff for identity proxy.</li>
      <li>Added stuff for stats.</li>
      <li>Added stuff peer and ice state reporting.</li>
      <li>Minor changes to sequence diagrams.</li>
      <li>Added a more complete RTCDataChannel example</li>
      <li>Various fixes from Dan's Idp API review.</li>
      <li>Patched the Stats API.</li>
    </ol>
    <h3>Changes since Aug 13, 2012</h3>
    <ol>
      <li>Made the RTCSessionDescription and RTCIceCandidate constructors take
      dictionaries instead of a strings. Also added detailed stringifier
      algorithm.</li>
      <li>Went through the list of issues (issue numbers are only valid with
      HEAD at fcda53c460). Closed (fixed/wontfix): 1, 8, 10, 13, 14, 16, 18,
      19, 22, 23, 24. Converted to notes: 4, 12. Updated: 9.</li>
      <li>Incorporate <a href=
      "http://lists.w3.org/Archives/Public/www-archive/2012Aug/0015.html">changes
      proposed</a> by Li Li.
      </li>
      <li>Use an enum for DataChannelState and fix IDLs where using an optional
      argument also requires all previous optional arguments to have a default
      value.</li>
    </ol>
    <h3>Changes since Jul 20, 2012</h3>
    <ol>
      <li>Added RTC Prefix to names (including the notes below).</li>
      <li>Moved to new definition of configuration and ice servers object.</li>
      <li>Added correlating lines to candidate structure.</li>
      <li>Converted setLocalDescription and setRemoteDescription to be
      asynchronous.</li>
      <li>Added call flows.</li>
    </ol>
    <h3>Changes since Jul 13, 2012</h3>
    <ol>
      <li>Removed peer attribute from RTCPeerConnectionIceEvent (duplicates
      functionality of Event.target attribute).</li>
      <li>Removed RTCIceCandidateCallback (no longer used).</li>
      <li>Removed RTCPeerConnectionEvent (we use a simple event instead).</li>
      <li>Removed RTCSdpType argument from setLocalDescription() and
      setRemoteDescription(). Updated simple example to match.</li>
    </ol>
    <h3>Changes since May 28, 2012</h3>
    <ol>
      <li>Changed names to use RTC Prefix.</li>
      <li>Changed the data structure used to pass in STUN and TURN servers in
      configuration.</li>
      <li>Updated simple RTCPeerConnection example (RTCPeerConnection
      constructor arguments; use icecandidate event).</li>
      <li>Initial import of new Data API.</li>
      <li>Removed some left-overs from the old Data Stream API.</li>
      <li>Renamed "underlying data channel" to "underlying data transport".
      Fixed closing procedures. Fixed some typos.</li>
    </ol>
    <h3>Changes since April 27, 2012</h3>
    <ol>
      <li>Major rewrite of RTCPeerConnection section to line up with IETF JSEP
      draft.</li>
      <li>Added simple RTCPeerConnection example. Initial update of
      RTCSessionDescription and RTCIceCandidate to support serialization and
      construction.</li>
    </ol>
    <h3>Changes since 21 April 2012</h3>
    <ol>
      <li>Moved MediaStream and related definitions to getUserMedia.</li>
      <li>Removed section "Obtaining local multimedia content".</li>
      <li>Updated getUserMedia() calls in examples (changes in Media Capture TF
      spec).</li>
      <li>Introduced MediaStreamTrackList interface with support for adding and
      removing tracks.</li>
      <li>Updated the algorithm that is run when RTCPeerConnection receives a
      stream (create new stream when negotiated instead of when data
      arrives).</li>
    </ol>
    <h3>Changes since 12 January 2012</h3>
    <ol>
      <li>Clarified the relation of Stream, Track, and Channel.</li>
    </ol>
    <h3>Changes since 17 October 2011</h3>
    <ol>
      <li>Tweak the introduction text and add a reference to the IETF RTCWEB
      group.</li>
      <li>Changed the first argument to getUserMedia to be an object.</li>
      <li>Added a MediaStreamHints object as a second argument to
      RTCPeerConnection.addStream.</li>
      <li>Added AudioMediaStreamTrack class and DTMF interface.</li>
    </ol>
    <h3>Changes since 23 August 2011</h3>
    <ol>
      <li>Separated the SDP and ICE Agent into separate agents and added
      explicit state attributes for each.</li>
      <li>Removed the send method from PeerConenction and associated callback
      function.</li>
      <li>Modified MediaStream() constructor to take a list of MediaStreamTrack
      objects instead of a MediaStream. Removed text about MediaStream parent
      and child relationship.</li>
      <li>Added abstract.</li>
      <li>Moved a few paragraphs from the MediaStreamTrack.label section to the
      MediaStream.label section (where they belong).</li>
      <li>Split MediaStream.tracks into MediaStream.audioTracks and
      MediaStream.videoTracks.</li>
      <li>Removed a sentence that implied that track access is limited to
      LocalMediaStream.</li>
      <li>Updated a few getUserMedia()-examples to use MediaStreamOptions.</li>
      <li>Replaced calls to URL.getObjectURL() with URL.createObjectURL() in
      example code.</li>
      <li>Fixed some broken getUserMedia() links.</li>
      <li>Introduced state handling on MediaStreamTrack (removed state handling
      from MediaStream).</li>
      <li>Reintroduced onended on MediaStream to simplify checking if all
      tracks are ended.</li>
      <li>Aligned the MediaStreamTrack ended event dispatching behavior with
      that of MediaStream.</li>
      <li>Updated the LocalMediaStream.stop() algorithm to implicitly use the
      end track algorithm.</li>
      <li>Replaced an occurrence the term finished track with ended track (to
      align with rest of spec).</li>
      <li>Moved (and extended) the explanation about track references and media
      sources from LocalMediaStream to MediaStreamTrack.</li>
    </ol>
  </section>
  <section class="appendix">
    <h2>Acknowledgements</h2>
    <p>The editors wish to thank the Working Group chairs and Team Contact,
    Harald Alvestrand, Stefan H&aring;kansson, Erik Lagerway and Dominique
    Haza&euml;l-Massieux, for their support. Substantial text in this
    specification was provided by many people including Martin Thomson, Harald
    Alvestrand, Justin Uberti, Eric Rescorla, Peter Thatcher, Jan-Ivar Bruaroey
    and Peter Saint-Andre. Dan Burnett would like to acknowledge the
    significant support received from Voxeo and Aspect during the development
    of this specification.</p>
    <p>The RTCRtpSender and RTCRtpReceiver objects were initially described in
    the <a href="https://www.w3.org/community/ortc/">W3C ORTC CG</a>, and have
    been adapted for use in this specification.</p>
  </section>
</body>
</html>
